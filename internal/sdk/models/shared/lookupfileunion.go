// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/internal/utils"
)

type LookupFileMode2 string

const (
	LookupFileMode2Memory LookupFileMode2 = "memory"
	LookupFileMode2Disk   LookupFileMode2 = "disk"
)

func (e LookupFileMode2) ToPointer() *LookupFileMode2 {
	return &e
}
func (e *LookupFileMode2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "memory":
		fallthrough
	case "disk":
		*e = LookupFileMode2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LookupFileMode2: %v", v)
	}
}

// LookupFileType2 - Task type
type LookupFileType2 string

const (
	LookupFileType2Import LookupFileType2 = "IMPORT"
	LookupFileType2Index  LookupFileType2 = "INDEX"
)

func (e LookupFileType2) ToPointer() *LookupFileType2 {
	return &e
}
func (e *LookupFileType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IMPORT":
		fallthrough
	case "INDEX":
		*e = LookupFileType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LookupFileType2: %v", v)
	}
}

type PendingTask2 struct {
	// Task ID (generated).
	ID *string `json:"id,omitempty"`
	// Task type
	Type *LookupFileType2 `json:"type,omitempty"`
	// Error message if task has failed
	Error *string `json:"error,omitempty"`
}

func (o *PendingTask2) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *PendingTask2) GetType() *LookupFileType2 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *PendingTask2) GetError() *string {
	if o == nil {
		return nil
	}
	return o.Error
}

type LookupFile2 struct {
	// File content.
	Content     *string `json:"content,omitempty"`
	ID          string  `json:"id"`
	Description *string `json:"description,omitempty"`
	// One or more tags related to this lookup. Optional.
	Tags *string `json:"tags,omitempty"`
	// File size. Optional.
	Size *float64 `json:"size,omitempty"`
	// Unique string generated for each modification of this lookup
	Version     *string          `json:"version,omitempty"`
	Mode        *LookupFileMode2 `default:"memory" json:"mode"`
	PendingTask *PendingTask2    `json:"pendingTask,omitempty"`
}

func (l LookupFile2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupFile2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LookupFile2) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *LookupFile2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *LookupFile2) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *LookupFile2) GetTags() *string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *LookupFile2) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *LookupFile2) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *LookupFile2) GetMode() *LookupFileMode2 {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *LookupFile2) GetPendingTask() *PendingTask2 {
	if o == nil {
		return nil
	}
	return o.PendingTask
}

type FileInfo struct {
	Filename string `json:"filename"`
}

func (o *FileInfo) GetFilename() string {
	if o == nil {
		return ""
	}
	return o.Filename
}

type LookupFileMode1 string

const (
	LookupFileMode1Memory LookupFileMode1 = "memory"
	LookupFileMode1Disk   LookupFileMode1 = "disk"
)

func (e LookupFileMode1) ToPointer() *LookupFileMode1 {
	return &e
}
func (e *LookupFileMode1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "memory":
		fallthrough
	case "disk":
		*e = LookupFileMode1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LookupFileMode1: %v", v)
	}
}

// LookupFileType1 - Task type
type LookupFileType1 string

const (
	LookupFileType1Import LookupFileType1 = "IMPORT"
	LookupFileType1Index  LookupFileType1 = "INDEX"
)

func (e LookupFileType1) ToPointer() *LookupFileType1 {
	return &e
}
func (e *LookupFileType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IMPORT":
		fallthrough
	case "INDEX":
		*e = LookupFileType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LookupFileType1: %v", v)
	}
}

type PendingTask1 struct {
	// Task ID (generated).
	ID *string `json:"id,omitempty"`
	// Task type
	Type *LookupFileType1 `json:"type,omitempty"`
	// Error message if task has failed
	Error *string `json:"error,omitempty"`
}

func (o *PendingTask1) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *PendingTask1) GetType() *LookupFileType1 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *PendingTask1) GetError() *string {
	if o == nil {
		return nil
	}
	return o.Error
}

type LookupFile1 struct {
	FileInfo    *FileInfo `json:"fileInfo,omitempty"`
	ID          string    `json:"id"`
	Description *string   `json:"description,omitempty"`
	// One or more tags related to this lookup. Optional.
	Tags *string `json:"tags,omitempty"`
	// File size. Optional.
	Size *float64 `json:"size,omitempty"`
	// Unique string generated for each modification of this lookup
	Version     *string          `json:"version,omitempty"`
	Mode        *LookupFileMode1 `default:"memory" json:"mode"`
	PendingTask *PendingTask1    `json:"pendingTask,omitempty"`
}

func (l LookupFile1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupFile1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LookupFile1) GetFileInfo() *FileInfo {
	if o == nil {
		return nil
	}
	return o.FileInfo
}

func (o *LookupFile1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *LookupFile1) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *LookupFile1) GetTags() *string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *LookupFile1) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *LookupFile1) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *LookupFile1) GetMode() *LookupFileMode1 {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *LookupFile1) GetPendingTask() *PendingTask1 {
	if o == nil {
		return nil
	}
	return o.PendingTask
}

type LookupFileUnionType string

const (
	LookupFileUnionTypeLookupFile1 LookupFileUnionType = "LookupFile_1"
	LookupFileUnionTypeLookupFile2 LookupFileUnionType = "LookupFile_2"
)

type LookupFileUnion struct {
	LookupFile1 *LookupFile1 `queryParam:"inline"`
	LookupFile2 *LookupFile2 `queryParam:"inline"`

	Type LookupFileUnionType
}

func CreateLookupFileUnionLookupFile1(lookupFile1 LookupFile1) LookupFileUnion {
	typ := LookupFileUnionTypeLookupFile1

	return LookupFileUnion{
		LookupFile1: &lookupFile1,
		Type:        typ,
	}
}

func CreateLookupFileUnionLookupFile2(lookupFile2 LookupFile2) LookupFileUnion {
	typ := LookupFileUnionTypeLookupFile2

	return LookupFileUnion{
		LookupFile2: &lookupFile2,
		Type:        typ,
	}
}

func (u *LookupFileUnion) UnmarshalJSON(data []byte) error {

	var lookupFile1 LookupFile1 = LookupFile1{}
	if err := utils.UnmarshalJSON(data, &lookupFile1, "", true, true); err == nil {
		u.LookupFile1 = &lookupFile1
		u.Type = LookupFileUnionTypeLookupFile1
		return nil
	}

	var lookupFile2 LookupFile2 = LookupFile2{}
	if err := utils.UnmarshalJSON(data, &lookupFile2, "", true, true); err == nil {
		u.LookupFile2 = &lookupFile2
		u.Type = LookupFileUnionTypeLookupFile2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LookupFileUnion", string(data))
}

func (u LookupFileUnion) MarshalJSON() ([]byte, error) {
	if u.LookupFile1 != nil {
		return utils.MarshalJSON(u.LookupFile1, "", true)
	}

	if u.LookupFile2 != nil {
		return utils.MarshalJSON(u.LookupFile2, "", true)
	}

	return nil, errors.New("could not marshal union type LookupFileUnion: all fields are null")
}

type LookupFileInput2 struct {
	// File content.
	Content     *string `json:"content,omitempty"`
	ID          string  `json:"id"`
	Description *string `json:"description,omitempty"`
	// One or more tags related to this lookup. Optional.
	Tags *string `json:"tags,omitempty"`
	// File size. Optional.
	Size *float64         `json:"size,omitempty"`
	Mode *LookupFileMode2 `default:"memory" json:"mode"`
}

func (l LookupFileInput2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupFileInput2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LookupFileInput2) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *LookupFileInput2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *LookupFileInput2) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *LookupFileInput2) GetTags() *string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *LookupFileInput2) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *LookupFileInput2) GetMode() *LookupFileMode2 {
	if o == nil {
		return nil
	}
	return o.Mode
}

type LookupFileInput1 struct {
	FileInfo    *FileInfo `json:"fileInfo,omitempty"`
	ID          string    `json:"id"`
	Description *string   `json:"description,omitempty"`
	// One or more tags related to this lookup. Optional.
	Tags *string `json:"tags,omitempty"`
	// File size. Optional.
	Size *float64         `json:"size,omitempty"`
	Mode *LookupFileMode1 `default:"memory" json:"mode"`
}

func (l LookupFileInput1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LookupFileInput1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *LookupFileInput1) GetFileInfo() *FileInfo {
	if o == nil {
		return nil
	}
	return o.FileInfo
}

func (o *LookupFileInput1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *LookupFileInput1) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *LookupFileInput1) GetTags() *string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *LookupFileInput1) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *LookupFileInput1) GetMode() *LookupFileMode1 {
	if o == nil {
		return nil
	}
	return o.Mode
}

type LookupFileInputUnionType string

const (
	LookupFileInputUnionTypeLookupFileInput1 LookupFileInputUnionType = "LookupFile_input_1"
	LookupFileInputUnionTypeLookupFileInput2 LookupFileInputUnionType = "LookupFile_input_2"
)

type LookupFileInputUnion struct {
	LookupFileInput1 *LookupFileInput1 `queryParam:"inline"`
	LookupFileInput2 *LookupFileInput2 `queryParam:"inline"`

	Type LookupFileInputUnionType
}

func CreateLookupFileInputUnionLookupFileInput1(lookupFileInput1 LookupFileInput1) LookupFileInputUnion {
	typ := LookupFileInputUnionTypeLookupFileInput1

	return LookupFileInputUnion{
		LookupFileInput1: &lookupFileInput1,
		Type:             typ,
	}
}

func CreateLookupFileInputUnionLookupFileInput2(lookupFileInput2 LookupFileInput2) LookupFileInputUnion {
	typ := LookupFileInputUnionTypeLookupFileInput2

	return LookupFileInputUnion{
		LookupFileInput2: &lookupFileInput2,
		Type:             typ,
	}
}

func (u *LookupFileInputUnion) UnmarshalJSON(data []byte) error {

	var lookupFileInput1 LookupFileInput1 = LookupFileInput1{}
	if err := utils.UnmarshalJSON(data, &lookupFileInput1, "", true, true); err == nil {
		u.LookupFileInput1 = &lookupFileInput1
		u.Type = LookupFileInputUnionTypeLookupFileInput1
		return nil
	}

	var lookupFileInput2 LookupFileInput2 = LookupFileInput2{}
	if err := utils.UnmarshalJSON(data, &lookupFileInput2, "", true, true); err == nil {
		u.LookupFileInput2 = &lookupFileInput2
		u.Type = LookupFileInputUnionTypeLookupFileInput2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LookupFileInputUnion", string(data))
}

func (u LookupFileInputUnion) MarshalJSON() ([]byte, error) {
	if u.LookupFileInput1 != nil {
		return utils.MarshalJSON(u.LookupFileInput1, "", true)
	}

	if u.LookupFileInput2 != nil {
		return utils.MarshalJSON(u.LookupFileInput2, "", true)
	}

	return nil, errors.New("could not marshal union type LookupFileInputUnion: all fields are null")
}
