// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/internal/utils"
)

type SMTPTargetType string

const (
	SMTPTargetTypeSMTP SMTPTargetType = "smtp"
)

func (e SMTPTargetType) ToPointer() *SMTPTargetType {
	return &e
}
func (e *SMTPTargetType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smtp":
		*e = SMTPTargetType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SMTPTargetType: %v", v)
	}
}

// Encryption method for SMTP
type Encryption string

const (
	EncryptionNone     Encryption = "NONE"
	EncryptionStarttls Encryption = "STARTTLS"
	EncryptionSsl      Encryption = "SSL"
)

func (e Encryption) ToPointer() *Encryption {
	return &e
}
func (e *Encryption) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NONE":
		fallthrough
	case "STARTTLS":
		fallthrough
	case "SSL":
		*e = Encryption(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Encryption: %v", v)
	}
}

// SMTPTargetMinimumTLSVersion - Minimum TLS version to accept
type SMTPTargetMinimumTLSVersion string

const (
	SMTPTargetMinimumTLSVersionTlSv1  SMTPTargetMinimumTLSVersion = "TLSv1"
	SMTPTargetMinimumTLSVersionTlSv11 SMTPTargetMinimumTLSVersion = "TLSv1.1"
	SMTPTargetMinimumTLSVersionTlSv12 SMTPTargetMinimumTLSVersion = "TLSv1.2"
	SMTPTargetMinimumTLSVersionTlSv13 SMTPTargetMinimumTLSVersion = "TLSv1.3"
)

func (e SMTPTargetMinimumTLSVersion) ToPointer() *SMTPTargetMinimumTLSVersion {
	return &e
}
func (e *SMTPTargetMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = SMTPTargetMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SMTPTargetMinimumTLSVersion: %v", v)
	}
}

// SMTPTargetMaximumTLSVersion - Maximum TLS version to accept
type SMTPTargetMaximumTLSVersion string

const (
	SMTPTargetMaximumTLSVersionTlSv1  SMTPTargetMaximumTLSVersion = "TLSv1"
	SMTPTargetMaximumTLSVersionTlSv11 SMTPTargetMaximumTLSVersion = "TLSv1.1"
	SMTPTargetMaximumTLSVersionTlSv12 SMTPTargetMaximumTLSVersion = "TLSv1.2"
	SMTPTargetMaximumTLSVersionTlSv13 SMTPTargetMaximumTLSVersion = "TLSv1.3"
)

func (e SMTPTargetMaximumTLSVersion) ToPointer() *SMTPTargetMaximumTLSVersion {
	return &e
}
func (e *SMTPTargetMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = SMTPTargetMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SMTPTargetMaximumTLSVersion: %v", v)
	}
}

// TLSConfiguration - TLS configuration options
type TLSConfiguration struct {
	// Whether to reject unauthorized certificates
	RejectUnauthorized *bool `default:"true" json:"rejectUnauthorized"`
	// Minimum TLS version to accept
	MinVersion *SMTPTargetMinimumTLSVersion `default:"TLSv1.2" json:"minVersion"`
	// Maximum TLS version to accept
	MaxVersion *SMTPTargetMaximumTLSVersion `default:"TLSv1.3" json:"maxVersion"`
}

func (t TLSConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TLSConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *TLSConfiguration) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *TLSConfiguration) GetMinVersion() *SMTPTargetMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *TLSConfiguration) GetMaxVersion() *SMTPTargetMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

type SMTPTarget struct {
	// Unique ID for this notification target
	ID   string         `json:"id"`
	Type SMTPTargetType `json:"type"`
	// Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
	SystemFields []string `json:"systemFields,omitempty"`
	// SMTP server hostname
	Host string `json:"host"`
	// SMTP server port
	Port int64 `json:"port"`
	// Email address to send from
	From string `json:"from"`
	// SMTP authentication username
	Username *string `json:"username,omitempty"`
	// SMTP authentication password
	Password *string `json:"password,omitempty"`
	// Encryption method for SMTP
	EncryptionOption *Encryption `default:"NONE" json:"encryptionOption"`
	// TLS configuration options
	TLS *TLSConfiguration `json:"tls,omitempty"`
}

func (s SMTPTarget) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SMTPTarget) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"id", "type", "host", "port", "from"}); err != nil {
		return err
	}
	return nil
}

func (o *SMTPTarget) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *SMTPTarget) GetType() SMTPTargetType {
	if o == nil {
		return SMTPTargetType("")
	}
	return o.Type
}

func (o *SMTPTarget) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *SMTPTarget) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *SMTPTarget) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *SMTPTarget) GetFrom() string {
	if o == nil {
		return ""
	}
	return o.From
}

func (o *SMTPTarget) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

func (o *SMTPTarget) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *SMTPTarget) GetEncryptionOption() *Encryption {
	if o == nil {
		return nil
	}
	return o.EncryptionOption
}

func (o *SMTPTarget) GetTLS() *TLSConfiguration {
	if o == nil {
		return nil
	}
	return o.TLS
}
