// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/internal/utils"
)

type ActionType string

const (
	ActionTypeStr        ActionType = "str"
	ActionTypeArrayOfStr ActionType = "arrayOfStr"
)

type Action struct {
	Str        *string  `queryParam:"inline,name=Action"`
	ArrayOfStr []string `queryParam:"inline,name=Action"`

	Type ActionType
}

func CreateActionStr(str string) Action {
	typ := ActionTypeStr

	return Action{
		Str:  &str,
		Type: typ,
	}
}

func CreateActionArrayOfStr(arrayOfStr []string) Action {
	typ := ActionTypeArrayOfStr

	return Action{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *Action) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActionTypeStr,
			Value: &str,
		})
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ActionTypeArrayOfStr,
			Value: arrayOfStr,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Action", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Action", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ActionType)
	switch best.Type {
	case ActionTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ActionTypeArrayOfStr:
		u.ArrayOfStr = best.Value.([]string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Action", string(data))
}

func (u Action) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type Action: all fields are null")
}

type StringEquals struct {
}

type AMTrustPolicyCondition struct {
	StringEquals *StringEquals `json:"StringEquals,omitempty"`
}

func (a *AMTrustPolicyCondition) GetStringEquals() *StringEquals {
	if a == nil {
		return nil
	}
	return a.StringEquals
}

type Principal struct {
	Aws string `json:"AWS"`
}

func (p *Principal) GetAws() string {
	if p == nil {
		return ""
	}
	return p.Aws
}

type Statement struct {
	Action    Action                  `json:"Action"`
	Condition *AMTrustPolicyCondition `json:"Condition,omitempty"`
	Effect    string                  `json:"Effect"`
	Principal Principal               `json:"Principal"`
}

func (s *Statement) GetAction() Action {
	if s == nil {
		return Action{}
	}
	return s.Action
}

func (s *Statement) GetCondition() *AMTrustPolicyCondition {
	if s == nil {
		return nil
	}
	return s.Condition
}

func (s *Statement) GetEffect() string {
	if s == nil {
		return ""
	}
	return s.Effect
}

func (s *Statement) GetPrincipal() Principal {
	if s == nil {
		return Principal{}
	}
	return s.Principal
}

type AMTrustPolicy struct {
	Statement []Statement `json:"Statement"`
	Version   string      `json:"Version"`
}

func (a *AMTrustPolicy) GetStatement() []Statement {
	if a == nil {
		return []Statement{}
	}
	return a.Statement
}

func (a *AMTrustPolicy) GetVersion() string {
	if a == nil {
		return ""
	}
	return a.Version
}
