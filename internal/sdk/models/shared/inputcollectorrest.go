// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/internal/utils"
)

type InputCollectorRestTypeCollection1 string

const (
	InputCollectorRestTypeCollection1Collection InputCollectorRestTypeCollection1 = "collection"
)

func (e InputCollectorRestTypeCollection1) ToPointer() *InputCollectorRestTypeCollection1 {
	return &e
}
func (e *InputCollectorRestTypeCollection1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "collection":
		*e = InputCollectorRestTypeCollection1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestTypeCollection1: %v", v)
	}
}

// InputCollectorRestSavedState - Saved state for the collector
type InputCollectorRestSavedState struct {
}

func (i InputCollectorRestSavedState) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestSavedState) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

// InputCollectorRestLogLevel - Level at which to set task logging
type InputCollectorRestLogLevel string

const (
	InputCollectorRestLogLevelError InputCollectorRestLogLevel = "error"
	InputCollectorRestLogLevelWarn  InputCollectorRestLogLevel = "warn"
	InputCollectorRestLogLevelInfo  InputCollectorRestLogLevel = "info"
	InputCollectorRestLogLevelDebug InputCollectorRestLogLevel = "debug"
	InputCollectorRestLogLevelSilly InputCollectorRestLogLevel = "silly"
)

func (e InputCollectorRestLogLevel) ToPointer() *InputCollectorRestLogLevel {
	return &e
}
func (e *InputCollectorRestLogLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "warn":
		fallthrough
	case "info":
		fallthrough
	case "debug":
		fallthrough
	case "silly":
		*e = InputCollectorRestLogLevel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestLogLevel: %v", v)
	}
}

// InputCollectorRestMode - Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
type InputCollectorRestMode string

const (
	InputCollectorRestModeList    InputCollectorRestMode = "list"
	InputCollectorRestModePreview InputCollectorRestMode = "preview"
	InputCollectorRestModeRun     InputCollectorRestMode = "run"
)

func (e InputCollectorRestMode) ToPointer() *InputCollectorRestMode {
	return &e
}
func (e *InputCollectorRestMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list":
		fallthrough
	case "preview":
		fallthrough
	case "run":
		*e = InputCollectorRestMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestMode: %v", v)
	}
}

type InputCollectorRestTimeRange string

const (
	InputCollectorRestTimeRangeRelative InputCollectorRestTimeRange = "relative"
	InputCollectorRestTimeRangeAbsolute InputCollectorRestTimeRange = "absolute"
)

func (e InputCollectorRestTimeRange) ToPointer() *InputCollectorRestTimeRange {
	return &e
}
func (e *InputCollectorRestTimeRange) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "relative":
		fallthrough
	case "absolute":
		*e = InputCollectorRestTimeRange(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestTimeRange: %v", v)
	}
}

// InputCollectorRestTimeWarning - Time warning configuration
type InputCollectorRestTimeWarning struct {
}

func (i InputCollectorRestTimeWarning) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestTimeWarning) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

// InputCollectorRestRunStateTracking - State tracking configuration
type InputCollectorRestRunStateTracking struct {
	StateUpdateExpression *string `json:"stateUpdateExpression,omitempty"`
	StateMergeExpression  *string `json:"stateMergeExpression,omitempty"`
	Enabled               *bool   `default:"false" json:"enabled"`
}

func (i InputCollectorRestRunStateTracking) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestRunStateTracking) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestRunStateTracking) GetStateUpdateExpression() *string {
	if i == nil {
		return nil
	}
	return i.StateUpdateExpression
}

func (i *InputCollectorRestRunStateTracking) GetStateMergeExpression() *string {
	if i == nil {
		return nil
	}
	return i.StateMergeExpression
}

func (i *InputCollectorRestRunStateTracking) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

type InputCollectorRestRunSettings struct {
	// Reschedule tasks that failed with non-fatal errors
	RescheduleDroppedTasks *bool `default:"true" json:"rescheduleDroppedTasks"`
	// Maximum number of times a task can be rescheduled
	MaxTaskReschedule *float64 `default:"1" json:"maxTaskReschedule"`
	// Level at which to set task logging
	LogLevel *InputCollectorRestLogLevel `default:"info" json:"logLevel"`
	// Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time.
	JobTimeout *string `default:"0" json:"jobTimeout"`
	// Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
	Mode          *InputCollectorRestMode      `default:"list" json:"mode"`
	TimeRangeType *InputCollectorRestTimeRange `default:"relative" json:"timeRangeType"`
	// Earliest time to collect data for the selected timezone
	Earliest *float64 `default:"0" json:"earliest"`
	// Latest time to collect data for the selected timezone
	Latest *float64 `default:"1" json:"latest"`
	// A filter for tokens in the provided collect path and/or the events being collected
	Expression *string `default:"true" json:"expression"`
	// Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
	MinTaskSize *string `default:"1MB" json:"minTaskSize"`
	// Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
	MaxTaskSize *string `default:"10MB" json:"maxTaskSize"`
	// Time warning configuration
	TimeWarning *InputCollectorRestTimeWarning `json:"timeWarning,omitempty"`
	// State tracking configuration
	StateTracking *InputCollectorRestRunStateTracking `json:"stateTracking,omitempty"`
}

func (i InputCollectorRestRunSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestRunSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestRunSettings) GetRescheduleDroppedTasks() *bool {
	if i == nil {
		return nil
	}
	return i.RescheduleDroppedTasks
}

func (i *InputCollectorRestRunSettings) GetMaxTaskReschedule() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxTaskReschedule
}

func (i *InputCollectorRestRunSettings) GetLogLevel() *InputCollectorRestLogLevel {
	if i == nil {
		return nil
	}
	return i.LogLevel
}

func (i *InputCollectorRestRunSettings) GetJobTimeout() *string {
	if i == nil {
		return nil
	}
	return i.JobTimeout
}

func (i *InputCollectorRestRunSettings) GetMode() *InputCollectorRestMode {
	if i == nil {
		return nil
	}
	return i.Mode
}

func (i *InputCollectorRestRunSettings) GetTimeRangeType() *InputCollectorRestTimeRange {
	if i == nil {
		return nil
	}
	return i.TimeRangeType
}

func (i *InputCollectorRestRunSettings) GetEarliest() *float64 {
	if i == nil {
		return nil
	}
	return i.Earliest
}

func (i *InputCollectorRestRunSettings) GetLatest() *float64 {
	if i == nil {
		return nil
	}
	return i.Latest
}

func (i *InputCollectorRestRunSettings) GetExpression() *string {
	if i == nil {
		return nil
	}
	return i.Expression
}

func (i *InputCollectorRestRunSettings) GetMinTaskSize() *string {
	if i == nil {
		return nil
	}
	return i.MinTaskSize
}

func (i *InputCollectorRestRunSettings) GetMaxTaskSize() *string {
	if i == nil {
		return nil
	}
	return i.MaxTaskSize
}

func (i *InputCollectorRestRunSettings) GetTimeWarning() *InputCollectorRestTimeWarning {
	if i == nil {
		return nil
	}
	return i.TimeWarning
}

func (i *InputCollectorRestRunSettings) GetStateTracking() *InputCollectorRestRunStateTracking {
	if i == nil {
		return nil
	}
	return i.StateTracking
}

// InputCollectorRestSchedule - Configuration for a scheduled job
type InputCollectorRestSchedule struct {
	// Enable to configure scheduling for this Collector
	Enabled *bool `json:"enabled,omitempty"`
	// A cron schedule on which to run this job
	CronSchedule *string `default:"*/5 * * * *" json:"cronSchedule"`
	// The maximum number of instances of this scheduled job that may be running at any time
	MaxConcurrentRuns *float64 `default:"1" json:"maxConcurrentRuns"`
	// Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits
	Skippable *bool `default:"true" json:"skippable"`
	// Resume missed scheduled runs
	ResumeMissed *bool                          `default:"false" json:"resumeMissed"`
	Run          *InputCollectorRestRunSettings `json:"run,omitempty"`
}

func (i InputCollectorRestSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestSchedule) GetEnabled() *bool {
	if i == nil {
		return nil
	}
	return i.Enabled
}

func (i *InputCollectorRestSchedule) GetCronSchedule() *string {
	if i == nil {
		return nil
	}
	return i.CronSchedule
}

func (i *InputCollectorRestSchedule) GetMaxConcurrentRuns() *float64 {
	if i == nil {
		return nil
	}
	return i.MaxConcurrentRuns
}

func (i *InputCollectorRestSchedule) GetSkippable() *bool {
	if i == nil {
		return nil
	}
	return i.Skippable
}

func (i *InputCollectorRestSchedule) GetResumeMissed() *bool {
	if i == nil {
		return nil
	}
	return i.ResumeMissed
}

func (i *InputCollectorRestSchedule) GetRun() *InputCollectorRestRunSettings {
	if i == nil {
		return nil
	}
	return i.Run
}

type InputCollectorRestTypeCollection2 string

const (
	InputCollectorRestTypeCollection2Collection InputCollectorRestTypeCollection2 = "collection"
)

func (e InputCollectorRestTypeCollection2) ToPointer() *InputCollectorRestTypeCollection2 {
	return &e
}
func (e *InputCollectorRestTypeCollection2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "collection":
		*e = InputCollectorRestTypeCollection2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestTypeCollection2: %v", v)
	}
}

type InputCollectorRestPreprocess struct {
	Disabled *bool `default:"true" json:"disabled"`
	// Command to feed the data through (via stdin) and process its output (stdout)
	Command *string `json:"command,omitempty"`
	// Arguments to be added to the custom command
	Args []string `json:"args,omitempty"`
}

func (i InputCollectorRestPreprocess) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestPreprocess) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestPreprocess) GetDisabled() *bool {
	if i == nil {
		return nil
	}
	return i.Disabled
}

func (i *InputCollectorRestPreprocess) GetCommand() *string {
	if i == nil {
		return nil
	}
	return i.Command
}

func (i *InputCollectorRestPreprocess) GetArgs() []string {
	if i == nil {
		return nil
	}
	return i.Args
}

type InputCollectorRestMetadatum struct {
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

func (i InputCollectorRestMetadatum) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestMetadatum) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"name", "value"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestMetadatum) GetName() string {
	if i == nil {
		return ""
	}
	return i.Name
}

func (i *InputCollectorRestMetadatum) GetValue() string {
	if i == nil {
		return ""
	}
	return i.Value
}

type InputCollectorRestInput struct {
	Type *InputCollectorRestTypeCollection2 `default:"collection" json:"type"`
	// A list of event-breaking rulesets that will be applied, in order, to the input data stream
	BreakerRulesets []string `json:"breakerRulesets,omitempty"`
	// How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
	StaleChannelFlushMs *float64 `default:"10000" json:"staleChannelFlushMs"`
	// Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
	SendToRoutes *bool                         `default:"true" json:"sendToRoutes"`
	Preprocess   *InputCollectorRestPreprocess `json:"preprocess,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string `default:"0" json:"throttleRatePerSec"`
	// Fields to add to events from this input
	Metadata []InputCollectorRestMetadatum `json:"metadata,omitempty"`
	// Pipeline to process results
	Pipeline *string `json:"pipeline,omitempty"`
	// Destination to send results to
	Output *string `json:"output,omitempty"`
}

func (i InputCollectorRestInput) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestInput) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestInput) GetType() *InputCollectorRestTypeCollection2 {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InputCollectorRestInput) GetBreakerRulesets() []string {
	if i == nil {
		return nil
	}
	return i.BreakerRulesets
}

func (i *InputCollectorRestInput) GetStaleChannelFlushMs() *float64 {
	if i == nil {
		return nil
	}
	return i.StaleChannelFlushMs
}

func (i *InputCollectorRestInput) GetSendToRoutes() *bool {
	if i == nil {
		return nil
	}
	return i.SendToRoutes
}

func (i *InputCollectorRestInput) GetPreprocess() *InputCollectorRestPreprocess {
	if i == nil {
		return nil
	}
	return i.Preprocess
}

func (i *InputCollectorRestInput) GetThrottleRatePerSec() *string {
	if i == nil {
		return nil
	}
	return i.ThrottleRatePerSec
}

func (i *InputCollectorRestInput) GetMetadata() []InputCollectorRestMetadatum {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InputCollectorRestInput) GetPipeline() *string {
	if i == nil {
		return nil
	}
	return i.Pipeline
}

func (i *InputCollectorRestInput) GetOutput() *string {
	if i == nil {
		return nil
	}
	return i.Output
}

type TypeRest string

const (
	TypeRestRest TypeRest = "rest"
)

func (e TypeRest) ToPointer() *TypeRest {
	return &e
}
func (e *TypeRest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "rest":
		*e = TypeRest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeRest: %v", v)
	}
}

type InputCollectorRestAuthentication string

const (
	InputCollectorRestAuthenticationNone              InputCollectorRestAuthentication = "none"
	InputCollectorRestAuthenticationBasic             InputCollectorRestAuthentication = "basic"
	InputCollectorRestAuthenticationBasicSecret       InputCollectorRestAuthentication = "basicSecret"
	InputCollectorRestAuthenticationToken             InputCollectorRestAuthentication = "token"
	InputCollectorRestAuthenticationTokenSecret       InputCollectorRestAuthentication = "tokenSecret"
	InputCollectorRestAuthenticationLogin             InputCollectorRestAuthentication = "login"
	InputCollectorRestAuthenticationLoginSecret       InputCollectorRestAuthentication = "loginSecret"
	InputCollectorRestAuthenticationOauth             InputCollectorRestAuthentication = "oauth"
	InputCollectorRestAuthenticationOauthSecret       InputCollectorRestAuthentication = "oauthSecret"
	InputCollectorRestAuthenticationGoogleOauth       InputCollectorRestAuthentication = "google_oauth"
	InputCollectorRestAuthenticationGoogleOauthSecret InputCollectorRestAuthentication = "google_oauthSecret"
	InputCollectorRestAuthenticationHmac              InputCollectorRestAuthentication = "hmac"
)

func (e InputCollectorRestAuthentication) ToPointer() *InputCollectorRestAuthentication {
	return &e
}
func (e *InputCollectorRestAuthentication) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "basic":
		fallthrough
	case "basicSecret":
		fallthrough
	case "token":
		fallthrough
	case "tokenSecret":
		fallthrough
	case "login":
		fallthrough
	case "loginSecret":
		fallthrough
	case "oauth":
		fallthrough
	case "oauthSecret":
		fallthrough
	case "google_oauth":
		fallthrough
	case "google_oauthSecret":
		fallthrough
	case "hmac":
		*e = InputCollectorRestAuthentication(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestAuthentication: %v", v)
	}
}

type AuthRequestParam struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (a AuthRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AuthRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AuthRequestParam) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AuthRequestParam) GetValue() *string {
	if a == nil {
		return nil
	}
	return a.Value
}

type AuthRequestHeader struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (a AuthRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AuthRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (a *AuthRequestHeader) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AuthRequestHeader) GetValue() *string {
	if a == nil {
		return nil
	}
	return a.Value
}

type InputCollectorRestCollectMethod string

const (
	InputCollectorRestCollectMethodGet          InputCollectorRestCollectMethod = "get"
	InputCollectorRestCollectMethodPost         InputCollectorRestCollectMethod = "post"
	InputCollectorRestCollectMethodPostWithBody InputCollectorRestCollectMethod = "post_with_body"
	InputCollectorRestCollectMethodOther        InputCollectorRestCollectMethod = "other"
)

func (e InputCollectorRestCollectMethod) ToPointer() *InputCollectorRestCollectMethod {
	return &e
}
func (e *InputCollectorRestCollectMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "get":
		fallthrough
	case "post":
		fallthrough
	case "post_with_body":
		fallthrough
	case "other":
		*e = InputCollectorRestCollectMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestCollectMethod: %v", v)
	}
}

type CollectRequestHeader struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (c CollectRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CollectRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CollectRequestHeader) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CollectRequestHeader) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

type CollectRequestParam struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (c CollectRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CollectRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *CollectRequestParam) GetName() *string {
	if c == nil {
		return nil
	}
	return c.Name
}

func (c *CollectRequestParam) GetValue() *string {
	if c == nil {
		return nil
	}
	return c.Value
}

type DiscoverType string

const (
	DiscoverTypeHTTP DiscoverType = "http"
)

func (e DiscoverType) ToPointer() *DiscoverType {
	return &e
}
func (e *DiscoverType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = DiscoverType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DiscoverType: %v", v)
	}
}

type DiscoverMethod string

const (
	DiscoverMethodGet          DiscoverMethod = "get"
	DiscoverMethodPost         DiscoverMethod = "post"
	DiscoverMethodPostWithBody DiscoverMethod = "post_with_body"
	DiscoverMethodOther        DiscoverMethod = "other"
)

func (e DiscoverMethod) ToPointer() *DiscoverMethod {
	return &e
}
func (e *DiscoverMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "get":
		fallthrough
	case "post":
		fallthrough
	case "post_with_body":
		fallthrough
	case "other":
		*e = DiscoverMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DiscoverMethod: %v", v)
	}
}

type DiscoverRequestHeader struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (d DiscoverRequestHeader) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DiscoverRequestHeader) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DiscoverRequestHeader) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DiscoverRequestHeader) GetValue() *string {
	if d == nil {
		return nil
	}
	return d.Value
}

type DiscoverRequestParam struct {
}

func (d DiscoverRequestParam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DiscoverRequestParam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

type DiscoveryConfiguration struct {
	DiscoverType           *DiscoverType           `json:"discoverType,omitempty"`
	DiscoverMethod         *DiscoverMethod         `json:"discoverMethod,omitempty"`
	Pagination             *PaginationConfig       `json:"pagination,omitempty"`
	EnableDiscoverCode     *bool                   `default:"false" json:"enableDiscoverCode"`
	ItemList               []string                `json:"itemList,omitempty"`
	DiscoverURL            *string                 `json:"discoverUrl,omitempty"`
	DiscoverRequestHeaders []DiscoverRequestHeader `json:"discoverRequestHeaders,omitempty"`
	DiscoverRequestParams  []DiscoverRequestParam  `json:"discoverRequestParams,omitempty"`
	DiscoverBody           *string                 `json:"discoverBody,omitempty"`
	FormatResultCode       *string                 `json:"formatResultCode,omitempty"`
	DiscoverDataField      *string                 `json:"discoverDataField,omitempty"`
}

func (d DiscoveryConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DiscoveryConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DiscoveryConfiguration) GetDiscoverType() *DiscoverType {
	if d == nil {
		return nil
	}
	return d.DiscoverType
}

func (d *DiscoveryConfiguration) GetDiscoverMethod() *DiscoverMethod {
	if d == nil {
		return nil
	}
	return d.DiscoverMethod
}

func (d *DiscoveryConfiguration) GetPagination() *PaginationConfig {
	if d == nil {
		return nil
	}
	return d.Pagination
}

func (d *DiscoveryConfiguration) GetEnableDiscoverCode() *bool {
	if d == nil {
		return nil
	}
	return d.EnableDiscoverCode
}

func (d *DiscoveryConfiguration) GetItemList() []string {
	if d == nil {
		return nil
	}
	return d.ItemList
}

func (d *DiscoveryConfiguration) GetDiscoverURL() *string {
	if d == nil {
		return nil
	}
	return d.DiscoverURL
}

func (d *DiscoveryConfiguration) GetDiscoverRequestHeaders() []DiscoverRequestHeader {
	if d == nil {
		return nil
	}
	return d.DiscoverRequestHeaders
}

func (d *DiscoveryConfiguration) GetDiscoverRequestParams() []DiscoverRequestParam {
	if d == nil {
		return nil
	}
	return d.DiscoverRequestParams
}

func (d *DiscoveryConfiguration) GetDiscoverBody() *string {
	if d == nil {
		return nil
	}
	return d.DiscoverBody
}

func (d *DiscoveryConfiguration) GetFormatResultCode() *string {
	if d == nil {
		return nil
	}
	return d.FormatResultCode
}

func (d *DiscoveryConfiguration) GetDiscoverDataField() *string {
	if d == nil {
		return nil
	}
	return d.DiscoverDataField
}

type InputCollectorRestRetryType string

const (
	InputCollectorRestRetryTypeBackoff InputCollectorRestRetryType = "backoff"
	InputCollectorRestRetryTypeFixed   InputCollectorRestRetryType = "fixed"
)

func (e InputCollectorRestRetryType) ToPointer() *InputCollectorRestRetryType {
	return &e
}
func (e *InputCollectorRestRetryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "backoff":
		fallthrough
	case "fixed":
		*e = InputCollectorRestRetryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputCollectorRestRetryType: %v", v)
	}
}

type RetryRulesConfiguration struct {
	Type                *InputCollectorRestRetryType `default:"backoff" json:"type"`
	Interval            *int64                       `default:"1000" json:"interval"`
	Limit               *int64                       `default:"5" json:"limit"`
	Multiplier          *float64                     `default:"2" json:"multiplier"`
	MaxIntervalMs       *int64                       `default:"20000" json:"maxIntervalMs"`
	Codes               []int64                      `json:"codes,omitempty"`
	EnableHeader        *bool                        `default:"true" json:"enableHeader"`
	RetryConnectTimeout *bool                        `default:"false" json:"retryConnectTimeout"`
	RetryConnectReset   *bool                        `default:"false" json:"retryConnectReset"`
	RetryHeaderName     *string                      `default:"retry-after" json:"retryHeaderName"`
}

func (r RetryRulesConfiguration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RetryRulesConfiguration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RetryRulesConfiguration) GetType() *InputCollectorRestRetryType {
	if r == nil {
		return nil
	}
	return r.Type
}

func (r *RetryRulesConfiguration) GetInterval() *int64 {
	if r == nil {
		return nil
	}
	return r.Interval
}

func (r *RetryRulesConfiguration) GetLimit() *int64 {
	if r == nil {
		return nil
	}
	return r.Limit
}

func (r *RetryRulesConfiguration) GetMultiplier() *float64 {
	if r == nil {
		return nil
	}
	return r.Multiplier
}

func (r *RetryRulesConfiguration) GetMaxIntervalMs() *int64 {
	if r == nil {
		return nil
	}
	return r.MaxIntervalMs
}

func (r *RetryRulesConfiguration) GetCodes() []int64 {
	if r == nil {
		return nil
	}
	return r.Codes
}

func (r *RetryRulesConfiguration) GetEnableHeader() *bool {
	if r == nil {
		return nil
	}
	return r.EnableHeader
}

func (r *RetryRulesConfiguration) GetRetryConnectTimeout() *bool {
	if r == nil {
		return nil
	}
	return r.RetryConnectTimeout
}

func (r *RetryRulesConfiguration) GetRetryConnectReset() *bool {
	if r == nil {
		return nil
	}
	return r.RetryConnectReset
}

func (r *RetryRulesConfiguration) GetRetryHeaderName() *string {
	if r == nil {
		return nil
	}
	return r.RetryHeaderName
}

type SchedulingStateTracking struct {
}

func (s SchedulingStateTracking) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchedulingStateTracking) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

type InternalScheduling struct {
	StateTracking *SchedulingStateTracking `json:"stateTracking,omitempty"`
}

func (i InternalScheduling) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalScheduling) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InternalScheduling) GetStateTracking() *SchedulingStateTracking {
	if i == nil {
		return nil
	}
	return i.StateTracking
}

type InputCollectorRestConf struct {
	Authentication    *InputCollectorRestAuthentication `json:"authentication,omitempty"`
	Username          *string                           `json:"username,omitempty"`
	Password          *string                           `json:"password,omitempty"`
	CredentialsSecret *string                           `json:"credentialsSecret,omitempty"`
	Token             *string                           `json:"token,omitempty"`
	TokenSecret       *string                           `json:"tokenSecret,omitempty"`
	// URL for authentication login
	LoginURL *string `json:"loginUrl,omitempty"`
	// Body content for login request
	LoginBody *string `json:"loginBody,omitempty"`
	// Header key for authentication
	AuthHeaderKey *string `json:"authHeaderKey,omitempty"`
	// Expression for auth header value
	AuthHeaderExpr        *string            `json:"authHeaderExpr,omitempty"`
	ClientSecretParamName *string            `json:"clientSecretParamName,omitempty"`
	AuthRequestParams     []AuthRequestParam `json:"authRequestParams,omitempty"`
	// Attribute name for token in response
	TokenRespAttribute *string             `json:"tokenRespAttribute,omitempty"`
	AuthRequestHeaders []AuthRequestHeader `json:"authRequestHeaders,omitempty"`
	// URL to use for the Collect operation
	CollectURL            *string                          `json:"collectUrl,omitempty"`
	CollectMethod         *InputCollectorRestCollectMethod `json:"collectMethod,omitempty"`
	CollectRequestHeaders []CollectRequestHeader           `json:"collectRequestHeaders,omitempty"`
	CollectRequestParams  []CollectRequestParam            `json:"collectRequestParams,omitempty"`
	Timeout               *int64                           `json:"timeout,omitempty"`
	UseRoundRobinDNS      *bool                            `json:"useRoundRobinDns,omitempty"`
	DisableTimeFilter     *bool                            `json:"disableTimeFilter,omitempty"`
	DecodeURL             *bool                            `default:"false" json:"decodeUrl"`
	RejectUnauthorized    *bool                            `json:"rejectUnauthorized,omitempty"`
	CaptureHeaders        *bool                            `default:"false" json:"captureHeaders"`
	SafeHeaders           []string                         `json:"safeHeaders,omitempty"`
	Discovery             *DiscoveryConfiguration          `json:"discovery,omitempty"`
	Pagination            *PaginationConfig                `json:"pagination,omitempty"`
	RetryRules            *RetryRulesConfiguration         `json:"retryRules,omitempty"`
	Scheduling            *InternalScheduling              `json:"__scheduling,omitempty"`
}

func (i InputCollectorRestConf) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestConf) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestConf) GetAuthentication() *InputCollectorRestAuthentication {
	if i == nil {
		return nil
	}
	return i.Authentication
}

func (i *InputCollectorRestConf) GetUsername() *string {
	if i == nil {
		return nil
	}
	return i.Username
}

func (i *InputCollectorRestConf) GetPassword() *string {
	if i == nil {
		return nil
	}
	return i.Password
}

func (i *InputCollectorRestConf) GetCredentialsSecret() *string {
	if i == nil {
		return nil
	}
	return i.CredentialsSecret
}

func (i *InputCollectorRestConf) GetToken() *string {
	if i == nil {
		return nil
	}
	return i.Token
}

func (i *InputCollectorRestConf) GetTokenSecret() *string {
	if i == nil {
		return nil
	}
	return i.TokenSecret
}

func (i *InputCollectorRestConf) GetLoginURL() *string {
	if i == nil {
		return nil
	}
	return i.LoginURL
}

func (i *InputCollectorRestConf) GetLoginBody() *string {
	if i == nil {
		return nil
	}
	return i.LoginBody
}

func (i *InputCollectorRestConf) GetAuthHeaderKey() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderKey
}

func (i *InputCollectorRestConf) GetAuthHeaderExpr() *string {
	if i == nil {
		return nil
	}
	return i.AuthHeaderExpr
}

func (i *InputCollectorRestConf) GetClientSecretParamName() *string {
	if i == nil {
		return nil
	}
	return i.ClientSecretParamName
}

func (i *InputCollectorRestConf) GetAuthRequestParams() []AuthRequestParam {
	if i == nil {
		return nil
	}
	return i.AuthRequestParams
}

func (i *InputCollectorRestConf) GetTokenRespAttribute() *string {
	if i == nil {
		return nil
	}
	return i.TokenRespAttribute
}

func (i *InputCollectorRestConf) GetAuthRequestHeaders() []AuthRequestHeader {
	if i == nil {
		return nil
	}
	return i.AuthRequestHeaders
}

func (i *InputCollectorRestConf) GetCollectURL() *string {
	if i == nil {
		return nil
	}
	return i.CollectURL
}

func (i *InputCollectorRestConf) GetCollectMethod() *InputCollectorRestCollectMethod {
	if i == nil {
		return nil
	}
	return i.CollectMethod
}

func (i *InputCollectorRestConf) GetCollectRequestHeaders() []CollectRequestHeader {
	if i == nil {
		return nil
	}
	return i.CollectRequestHeaders
}

func (i *InputCollectorRestConf) GetCollectRequestParams() []CollectRequestParam {
	if i == nil {
		return nil
	}
	return i.CollectRequestParams
}

func (i *InputCollectorRestConf) GetTimeout() *int64 {
	if i == nil {
		return nil
	}
	return i.Timeout
}

func (i *InputCollectorRestConf) GetUseRoundRobinDNS() *bool {
	if i == nil {
		return nil
	}
	return i.UseRoundRobinDNS
}

func (i *InputCollectorRestConf) GetDisableTimeFilter() *bool {
	if i == nil {
		return nil
	}
	return i.DisableTimeFilter
}

func (i *InputCollectorRestConf) GetDecodeURL() *bool {
	if i == nil {
		return nil
	}
	return i.DecodeURL
}

func (i *InputCollectorRestConf) GetRejectUnauthorized() *bool {
	if i == nil {
		return nil
	}
	return i.RejectUnauthorized
}

func (i *InputCollectorRestConf) GetCaptureHeaders() *bool {
	if i == nil {
		return nil
	}
	return i.CaptureHeaders
}

func (i *InputCollectorRestConf) GetSafeHeaders() []string {
	if i == nil {
		return nil
	}
	return i.SafeHeaders
}

func (i *InputCollectorRestConf) GetDiscovery() *DiscoveryConfiguration {
	if i == nil {
		return nil
	}
	return i.Discovery
}

func (i *InputCollectorRestConf) GetPagination() *PaginationConfig {
	if i == nil {
		return nil
	}
	return i.Pagination
}

func (i *InputCollectorRestConf) GetRetryRules() *RetryRulesConfiguration {
	if i == nil {
		return nil
	}
	return i.RetryRules
}

func (i *InputCollectorRestConf) GetScheduling() *InternalScheduling {
	if i == nil {
		return nil
	}
	return i.Scheduling
}

type InputCollectorRestCollector struct {
	Type TypeRest                `json:"type"`
	Conf *InputCollectorRestConf `json:"conf,omitempty"`
}

func (i InputCollectorRestCollector) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRestCollector) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRestCollector) GetType() TypeRest {
	if i == nil {
		return TypeRest("")
	}
	return i.Type
}

func (i *InputCollectorRestCollector) GetConf() *InputCollectorRestConf {
	if i == nil {
		return nil
	}
	return i.Conf
}

type InputCollectorRest struct {
	ID                   *string                            `json:"id,omitempty"`
	Type                 *InputCollectorRestTypeCollection1 `default:"collection" json:"type"`
	TTL                  *string                            `default:"4h" json:"ttl"`
	IgnoreGroupJobsLimit *bool                              `default:"false" json:"ignoreGroupJobsLimit"`
	RemoveFields         []string                           `json:"removeFields,omitempty"`
	ResumeOnBoot         *bool                              `default:"true" json:"resumeOnBoot"`
	Environment          *string                            `json:"environment,omitempty"`
	// Saved state for the collector
	SavedState *InputCollectorRestSavedState `json:"savedState,omitempty"`
	// Configuration for a scheduled job
	Schedule *InputCollectorRestSchedule `json:"schedule,omitempty"`
	// Tags for filtering and grouping
	Streamtags []string `json:"streamtags,omitempty"`
	// If enabled, tasks are created and run by the same Worker Node
	WorkerAffinity *bool                       `default:"false" json:"workerAffinity"`
	Input          *InputCollectorRestInput    `json:"input,omitempty"`
	Collector      InputCollectorRestCollector `json:"collector"`
}

func (i InputCollectorRest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputCollectorRest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"collector"}); err != nil {
		return err
	}
	return nil
}

func (i *InputCollectorRest) GetID() *string {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InputCollectorRest) GetType() *InputCollectorRestTypeCollection1 {
	if i == nil {
		return nil
	}
	return i.Type
}

func (i *InputCollectorRest) GetTTL() *string {
	if i == nil {
		return nil
	}
	return i.TTL
}

func (i *InputCollectorRest) GetIgnoreGroupJobsLimit() *bool {
	if i == nil {
		return nil
	}
	return i.IgnoreGroupJobsLimit
}

func (i *InputCollectorRest) GetRemoveFields() []string {
	if i == nil {
		return nil
	}
	return i.RemoveFields
}

func (i *InputCollectorRest) GetResumeOnBoot() *bool {
	if i == nil {
		return nil
	}
	return i.ResumeOnBoot
}

func (i *InputCollectorRest) GetEnvironment() *string {
	if i == nil {
		return nil
	}
	return i.Environment
}

func (i *InputCollectorRest) GetSavedState() *InputCollectorRestSavedState {
	if i == nil {
		return nil
	}
	return i.SavedState
}

func (i *InputCollectorRest) GetSchedule() *InputCollectorRestSchedule {
	if i == nil {
		return nil
	}
	return i.Schedule
}

func (i *InputCollectorRest) GetStreamtags() []string {
	if i == nil {
		return nil
	}
	return i.Streamtags
}

func (i *InputCollectorRest) GetWorkerAffinity() *bool {
	if i == nil {
		return nil
	}
	return i.WorkerAffinity
}

func (i *InputCollectorRest) GetInput() *InputCollectorRestInput {
	if i == nil {
		return nil
	}
	return i.Input
}

func (i *InputCollectorRest) GetCollector() InputCollectorRestCollector {
	if i == nil {
		return InputCollectorRestCollector{}
	}
	return i.Collector
}
