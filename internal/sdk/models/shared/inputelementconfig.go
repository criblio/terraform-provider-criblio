// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/internal/utils"
)

type ApplyMode string

const (
	ApplyModeAuto   ApplyMode = "auto"
	ApplyModeManual ApplyMode = "manual"
)

func (e ApplyMode) ToPointer() *ApplyMode {
	return &e
}
func (e *ApplyMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "manual":
		*e = ApplyMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ApplyMode: %v", v)
	}
}

type InputElementConfigEarliestType string

const (
	InputElementConfigEarliestTypeStr    InputElementConfigEarliestType = "str"
	InputElementConfigEarliestTypeNumber InputElementConfigEarliestType = "number"
)

type InputElementConfigEarliest struct {
	Str    *string  `queryParam:"inline,name=earliest"`
	Number *float64 `queryParam:"inline,name=earliest"`

	Type InputElementConfigEarliestType
}

func CreateInputElementConfigEarliestStr(str string) InputElementConfigEarliest {
	typ := InputElementConfigEarliestTypeStr

	return InputElementConfigEarliest{
		Str:  &str,
		Type: typ,
	}
}

func CreateInputElementConfigEarliestNumber(number float64) InputElementConfigEarliest {
	typ := InputElementConfigEarliestTypeNumber

	return InputElementConfigEarliest{
		Number: &number,
		Type:   typ,
	}
}

func (u *InputElementConfigEarliest) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputElementConfigEarliestTypeStr,
			Value: &str,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputElementConfigEarliestTypeNumber,
			Value: &number,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElementConfigEarliest", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElementConfigEarliest", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(InputElementConfigEarliestType)
	switch best.Type {
	case InputElementConfigEarliestTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case InputElementConfigEarliestTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElementConfigEarliest", string(data))
}

func (u InputElementConfigEarliest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type InputElementConfigEarliest: all fields are null")
}

type InputElementConfigLatestType string

const (
	InputElementConfigLatestTypeStr    InputElementConfigLatestType = "str"
	InputElementConfigLatestTypeNumber InputElementConfigLatestType = "number"
)

type InputElementConfigLatest struct {
	Str    *string  `queryParam:"inline,name=latest"`
	Number *float64 `queryParam:"inline,name=latest"`

	Type InputElementConfigLatestType
}

func CreateInputElementConfigLatestStr(str string) InputElementConfigLatest {
	typ := InputElementConfigLatestTypeStr

	return InputElementConfigLatest{
		Str:  &str,
		Type: typ,
	}
}

func CreateInputElementConfigLatestNumber(number float64) InputElementConfigLatest {
	typ := InputElementConfigLatestTypeNumber

	return InputElementConfigLatest{
		Number: &number,
		Type:   typ,
	}
}

func (u *InputElementConfigLatest) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputElementConfigLatestTypeStr,
			Value: &str,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InputElementConfigLatestTypeNumber,
			Value: &number,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElementConfigLatest", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElementConfigLatest", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(InputElementConfigLatestType)
	switch best.Type {
	case InputElementConfigLatestTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case InputElementConfigLatestTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InputElementConfigLatest", string(data))
}

func (u InputElementConfigLatest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type InputElementConfigLatest: all fields are null")
}

type DefaultValue struct {
	Earliest InputElementConfigEarliest `json:"earliest"`
	Latest   InputElementConfigLatest   `json:"latest"`
	Timezone *string                    `json:"timezone,omitempty"`
}

func (d DefaultValue) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DefaultValue) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"earliest", "latest"}); err != nil {
		return err
	}
	return nil
}

func (d *DefaultValue) GetEarliest() InputElementConfigEarliest {
	if d == nil {
		return InputElementConfigEarliest{}
	}
	return d.Earliest
}

func (d *DefaultValue) GetLatest() InputElementConfigLatest {
	if d == nil {
		return InputElementConfigLatest{}
	}
	return d.Latest
}

func (d *DefaultValue) GetTimezone() *string {
	if d == nil {
		return nil
	}
	return d.Timezone
}

type DefaultValueUnionType string

const (
	DefaultValueUnionTypeStr          DefaultValueUnionType = "str"
	DefaultValueUnionTypeNumber       DefaultValueUnionType = "number"
	DefaultValueUnionTypeDefaultValue DefaultValueUnionType = "defaultValue"
)

type DefaultValueUnion struct {
	Str          *string       `queryParam:"inline,name=defaultValue"`
	Number       *float64      `queryParam:"inline,name=defaultValue"`
	DefaultValue *DefaultValue `queryParam:"inline,name=defaultValue"`

	Type DefaultValueUnionType
}

func CreateDefaultValueUnionStr(str string) DefaultValueUnion {
	typ := DefaultValueUnionTypeStr

	return DefaultValueUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateDefaultValueUnionNumber(number float64) DefaultValueUnion {
	typ := DefaultValueUnionTypeNumber

	return DefaultValueUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateDefaultValueUnionDefaultValue(defaultValue DefaultValue) DefaultValueUnion {
	typ := DefaultValueUnionTypeDefaultValue

	return DefaultValueUnion{
		DefaultValue: &defaultValue,
		Type:         typ,
	}
}

func (u *DefaultValueUnion) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var defaultValue DefaultValue = DefaultValue{}
	if err := utils.UnmarshalJSON(data, &defaultValue, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DefaultValueUnionTypeDefaultValue,
			Value: &defaultValue,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DefaultValueUnionTypeStr,
			Value: &str,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  DefaultValueUnionTypeNumber,
			Value: &number,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DefaultValueUnion", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for DefaultValueUnion", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(DefaultValueUnionType)
	switch best.Type {
	case DefaultValueUnionTypeDefaultValue:
		u.DefaultValue = best.Value.(*DefaultValue)
		return nil
	case DefaultValueUnionTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case DefaultValueUnionTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DefaultValueUnion", string(data))
}

func (u DefaultValueUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DefaultValue != nil {
		return utils.MarshalJSON(u.DefaultValue, "", true)
	}

	return nil, errors.New("could not marshal union type DefaultValueUnion: all fields are null")
}

type InputElementConfig struct {
	ApplyMode    *ApplyMode         `json:"applyMode,omitempty"`
	DebounceMs   *float64           `json:"debounceMs,omitempty"`
	DefaultValue *DefaultValueUnion `json:"defaultValue,omitempty"`
}

func (i InputElementConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InputElementConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (i *InputElementConfig) GetApplyMode() *ApplyMode {
	if i == nil {
		return nil
	}
	return i.ApplyMode
}

func (i *InputElementConfig) GetDebounceMs() *float64 {
	if i == nil {
		return nil
	}
	return i.DebounceMs
}

func (i *InputElementConfig) GetDefaultValue() *DefaultValueUnion {
	if i == nil {
		return nil
	}
	return i.DefaultValue
}
