// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package hooks

import (
	"errors"
	"net/http"
)

var _ error = (*FailEarly)(nil)

func (f *FailEarly) Error() string {
	return f.Cause.Error()
}

var _ sdkInitHook = (*Hooks)(nil)
var _ beforeRequestHook = (*Hooks)(nil)
var _ afterSuccessHook = (*Hooks)(nil)
var _ afterErrorHook = (*Hooks)(nil)

func New() *Hooks {
	cc := NewClientCredentialsHook()

	h := &Hooks{
		sdkInitHooks: []sdkInitHook{
			cc,
		},
		beforeRequestHook: []beforeRequestHook{
			cc,
		},
		afterSuccessHook: []afterSuccessHook{},
		afterErrorHook: []afterErrorHook{
			cc,
		},
	}

	initHooks(h)

	return h
}

// registerSDKInitHook registers a hook to be used by the SDK for the initialization event.
func (h *Hooks) registerSDKInitHook(hook sdkInitHook) {
	h.sdkInitHooks = append(h.sdkInitHooks, hook)
}

// registerBeforeRequestHook registers a hook to be used by the SDK for the before request event.
func (h *Hooks) registerBeforeRequestHook(hook beforeRequestHook) {
	h.beforeRequestHook = append(h.beforeRequestHook, hook)
}

// registerAfterSuccessHook registers a hook to be used by the SDK for the after success event.
func (h *Hooks) registerAfterSuccessHook(hook afterSuccessHook) {
	h.afterSuccessHook = append(h.afterSuccessHook, hook)
}

// registerAfterErrorHook registers a hook to be used by the SDK for the after error event.
func (h *Hooks) registerAfterErrorHook(hook afterErrorHook) {
	h.afterErrorHook = append(h.afterErrorHook, hook)
}

func (h *Hooks) SDKInit(baseURL string, client HTTPClient) (string, HTTPClient) {
	for _, hook := range h.sdkInitHooks {
		baseURL, client = hook.SDKInit(baseURL, client)
	}
	return baseURL, client
}

func (h *Hooks) BeforeRequest(hookCtx BeforeRequestContext, req *http.Request) (*http.Request, error) {
	for _, hook := range h.beforeRequestHook {
		var err error
		req, err = hook.BeforeRequest(hookCtx, req)
		if err != nil {
			return req, err
		}
	}
	return req, nil
}

func (h *Hooks) AfterSuccess(hookCtx AfterSuccessContext, res *http.Response) (*http.Response, error) {
	for _, hook := range h.afterSuccessHook {
		var err error
		res, err = hook.AfterSuccess(hookCtx, res)
		if err != nil {
			return res, err
		}
	}
	return res, nil
}

func (h *Hooks) AfterError(hookCtx AfterErrorContext, res *http.Response, err error) (*http.Response, error) {
	for _, hook := range h.afterErrorHook {
		res, err = hook.AfterError(hookCtx, res, err)
		var fe *FailEarly
		if errors.As(err, &fe) {
			return nil, fe.Cause
		}
	}
	return res, err
}
