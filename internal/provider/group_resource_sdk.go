// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/operations"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *GroupResourceModel) RefreshFromOperationsCreateProductsGroupsByProductResponseBody(ctx context.Context, resp *operations.CreateProductsGroupsByProductResponseBody) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Items = []tfTypes.Group{}

		for _, itemsItem := range resp.Items {
			var items tfTypes.Group

			if itemsItem.Cloud == nil {
				items.Cloud = nil
			} else {
				items.Cloud = &tfTypes.Cloud{}
				items.Cloud.Provider = types.StringValue(string(itemsItem.Cloud.Provider))
				items.Cloud.Region = types.StringValue(itemsItem.Cloud.Region)
			}
			items.EstimatedIngestRate = types.Float64PointerValue(itemsItem.EstimatedIngestRate)
			items.ID = types.StringValue(itemsItem.ID)
			items.IsFleet = types.BoolPointerValue(itemsItem.IsFleet)
			items.Name = types.StringPointerValue(itemsItem.Name)
			items.OnPrem = types.BoolPointerValue(itemsItem.OnPrem)
			items.Provisioned = types.BoolValue(itemsItem.Provisioned)
			items.Streamtags = make([]types.String, 0, len(itemsItem.Streamtags))
			for _, v := range itemsItem.Streamtags {
				items.Streamtags = append(items.Streamtags, types.StringValue(v))
			}
			items.WorkerRemoteAccess = types.BoolPointerValue(itemsItem.WorkerRemoteAccess)

			r.Items = append(r.Items, items)
		}
	}

	return diags
}

func (r *GroupResourceModel) RefreshFromOperationsGetGroupsByIDResponseBody(ctx context.Context, resp *operations.GetGroupsByIDResponseBody) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Items = []tfTypes.Group{}

		for _, itemsItem := range resp.Items {
			var items tfTypes.Group

			if itemsItem.Cloud == nil {
				items.Cloud = nil
			} else {
				items.Cloud = &tfTypes.Cloud{}
				items.Cloud.Provider = types.StringValue(string(itemsItem.Cloud.Provider))
				items.Cloud.Region = types.StringValue(itemsItem.Cloud.Region)
			}
			items.EstimatedIngestRate = types.Float64PointerValue(itemsItem.EstimatedIngestRate)
			items.ID = types.StringValue(itemsItem.ID)
			items.IsFleet = types.BoolPointerValue(itemsItem.IsFleet)
			items.Name = types.StringPointerValue(itemsItem.Name)
			items.OnPrem = types.BoolPointerValue(itemsItem.OnPrem)
			items.Provisioned = types.BoolValue(itemsItem.Provisioned)
			items.Streamtags = make([]types.String, 0, len(itemsItem.Streamtags))
			for _, v := range itemsItem.Streamtags {
				items.Streamtags = append(items.Streamtags, types.StringValue(v))
			}
			items.WorkerRemoteAccess = types.BoolPointerValue(itemsItem.WorkerRemoteAccess)

			r.Items = append(r.Items, items)
		}
	}

	return diags
}

func (r *GroupResourceModel) RefreshFromOperationsUpdateGroupsByIDResponseBody(ctx context.Context, resp *operations.UpdateGroupsByIDResponseBody) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Items = []tfTypes.Group{}

		for _, itemsItem := range resp.Items {
			var items tfTypes.Group

			if itemsItem.Cloud == nil {
				items.Cloud = nil
			} else {
				items.Cloud = &tfTypes.Cloud{}
				items.Cloud.Provider = types.StringValue(string(itemsItem.Cloud.Provider))
				items.Cloud.Region = types.StringValue(itemsItem.Cloud.Region)
			}
			items.EstimatedIngestRate = types.Float64PointerValue(itemsItem.EstimatedIngestRate)
			items.ID = types.StringValue(itemsItem.ID)
			items.IsFleet = types.BoolPointerValue(itemsItem.IsFleet)
			items.Name = types.StringPointerValue(itemsItem.Name)
			items.OnPrem = types.BoolPointerValue(itemsItem.OnPrem)
			items.Provisioned = types.BoolValue(itemsItem.Provisioned)
			items.Streamtags = make([]types.String, 0, len(itemsItem.Streamtags))
			for _, v := range itemsItem.Streamtags {
				items.Streamtags = append(items.Streamtags, types.StringValue(v))
			}
			items.WorkerRemoteAccess = types.BoolPointerValue(itemsItem.WorkerRemoteAccess)

			r.Items = append(r.Items, items)
		}
	}

	return diags
}

func (r *GroupResourceModel) ToOperationsCreateProductsGroupsByProductRequest(ctx context.Context) (*operations.CreateProductsGroupsByProductRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	product := operations.CreateProductsGroupsByProductProduct(r.Product.ValueString())
	configGroup, configGroupDiags := r.ToSharedConfigGroup(ctx)
	diags.Append(configGroupDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateProductsGroupsByProductRequest{
		Product:     product,
		ConfigGroup: *configGroup,
	}

	return &out, diags
}

func (r *GroupResourceModel) ToOperationsDeleteGroupsByIDRequest(ctx context.Context) (*operations.DeleteGroupsByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.DeleteGroupsByIDRequest{
		ID: id,
	}

	return &out, diags
}

func (r *GroupResourceModel) ToOperationsGetGroupsByIDRequest(ctx context.Context) (*operations.GetGroupsByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.GetGroupsByIDRequest{
		ID: id,
	}

	return &out, diags
}

func (r *GroupResourceModel) ToOperationsUpdateGroupsByIDRequest(ctx context.Context) (*operations.UpdateGroupsByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.UpdateGroupsByIDRequest{
		ID: id,
	}

	return &out, diags
}

func (r *GroupResourceModel) ToSharedConfigGroup(ctx context.Context) (*shared.ConfigGroup, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cloud *shared.ConfigGroupCloud
	if r.Cloud != nil {
		provider := new(shared.CloudProvider)
		if !r.Cloud.Provider.IsUnknown() && !r.Cloud.Provider.IsNull() {
			*provider = shared.CloudProvider(r.Cloud.Provider.ValueString())
		} else {
			provider = nil
		}
		var region string
		region = r.Cloud.Region.ValueString()

		cloud = &shared.ConfigGroupCloud{
			Provider: provider,
			Region:   region,
		}
	}
	configVersion := new(string)
	if !r.ConfigVersion.IsUnknown() && !r.ConfigVersion.IsNull() {
		*configVersion = r.ConfigVersion.ValueString()
	} else {
		configVersion = nil
	}
	deployingWorkerCount := new(float64)
	if !r.DeployingWorkerCount.IsUnknown() && !r.DeployingWorkerCount.IsNull() {
		*deployingWorkerCount = r.DeployingWorkerCount.ValueFloat64()
	} else {
		deployingWorkerCount = nil
	}
	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	estimatedIngestRate := new(float64)
	if !r.EstimatedIngestRate.IsUnknown() && !r.EstimatedIngestRate.IsNull() {
		*estimatedIngestRate = r.EstimatedIngestRate.ValueFloat64()
	} else {
		estimatedIngestRate = nil
	}
	var git *shared.ConfigGroupGit
	if r.Git != nil {
		commit := new(string)
		if !r.Git.Commit.IsUnknown() && !r.Git.Commit.IsNull() {
			*commit = r.Git.Commit.ValueString()
		} else {
			commit = nil
		}
		localChanges := new(float64)
		if !r.Git.LocalChanges.IsUnknown() && !r.Git.LocalChanges.IsNull() {
			*localChanges = r.Git.LocalChanges.ValueFloat64()
		} else {
			localChanges = nil
		}
		log := make([]shared.Commit, 0, len(r.Git.Log))
		for _, logItem := range r.Git.Log {
			authorEmail := new(string)
			if !logItem.AuthorEmail.IsUnknown() && !logItem.AuthorEmail.IsNull() {
				*authorEmail = logItem.AuthorEmail.ValueString()
			} else {
				authorEmail = nil
			}
			authorName := new(string)
			if !logItem.AuthorName.IsUnknown() && !logItem.AuthorName.IsNull() {
				*authorName = logItem.AuthorName.ValueString()
			} else {
				authorName = nil
			}
			var date string
			date = logItem.Date.ValueString()

			var hash string
			hash = logItem.Hash.ValueString()

			var message string
			message = logItem.Message.ValueString()

			var short string
			short = logItem.Short.ValueString()

			log = append(log, shared.Commit{
				AuthorEmail: authorEmail,
				AuthorName:  authorName,
				Date:        date,
				Hash:        hash,
				Message:     message,
				Short:       short,
			})
		}
		git = &shared.ConfigGroupGit{
			Commit:       commit,
			LocalChanges: localChanges,
			Log:          log,
		}
	}
	var id string
	id = r.ID.ValueString()

	incompatibleWorkerCount := new(float64)
	if !r.IncompatibleWorkerCount.IsUnknown() && !r.IncompatibleWorkerCount.IsNull() {
		*incompatibleWorkerCount = r.IncompatibleWorkerCount.ValueFloat64()
	} else {
		incompatibleWorkerCount = nil
	}
	inherits := new(string)
	if !r.Inherits.IsUnknown() && !r.Inherits.IsNull() {
		*inherits = r.Inherits.ValueString()
	} else {
		inherits = nil
	}
	isFleet := new(bool)
	if !r.IsFleet.IsUnknown() && !r.IsFleet.IsNull() {
		*isFleet = r.IsFleet.ValueBool()
	} else {
		isFleet = nil
	}
	isSearch := new(bool)
	if !r.IsSearch.IsUnknown() && !r.IsSearch.IsNull() {
		*isSearch = r.IsSearch.ValueBool()
	} else {
		isSearch = nil
	}
	lookupDeployments := make([]shared.ConfigGroupLookups, 0, len(r.LookupDeployments))
	for _, lookupDeploymentsItem := range r.LookupDeployments {
		var contextVar string
		contextVar = lookupDeploymentsItem.Context.ValueString()

		lookups := make([]shared.Lookup, 0, len(lookupDeploymentsItem.Lookups))
		for _, lookupsItem := range lookupDeploymentsItem.Lookups {
			deployedVersion := new(string)
			if !lookupsItem.DeployedVersion.IsUnknown() && !lookupsItem.DeployedVersion.IsNull() {
				*deployedVersion = lookupsItem.DeployedVersion.ValueString()
			} else {
				deployedVersion = nil
			}
			var file string
			file = lookupsItem.File.ValueString()

			version := new(string)
			if !lookupsItem.Version.IsUnknown() && !lookupsItem.Version.IsNull() {
				*version = lookupsItem.Version.ValueString()
			} else {
				version = nil
			}
			lookups = append(lookups, shared.Lookup{
				DeployedVersion: deployedVersion,
				File:            file,
				Version:         version,
			})
		}
		lookupDeployments = append(lookupDeployments, shared.ConfigGroupLookups{
			Context: contextVar,
			Lookups: lookups,
		})
	}
	name := new(string)
	if !r.Name.IsUnknown() && !r.Name.IsNull() {
		*name = r.Name.ValueString()
	} else {
		name = nil
	}
	onPrem := new(bool)
	if !r.OnPrem.IsUnknown() && !r.OnPrem.IsNull() {
		*onPrem = r.OnPrem.ValueBool()
	} else {
		onPrem = nil
	}
	provisioned := new(bool)
	if !r.Provisioned.IsUnknown() && !r.Provisioned.IsNull() {
		*provisioned = r.Provisioned.ValueBool()
	} else {
		provisioned = nil
	}
	streamtags := make([]string, 0, len(r.Streamtags))
	for _, streamtagsItem := range r.Streamtags {
		streamtags = append(streamtags, streamtagsItem.ValueString())
	}
	tags := new(string)
	if !r.Tags.IsUnknown() && !r.Tags.IsNull() {
		*tags = r.Tags.ValueString()
	} else {
		tags = nil
	}
	typeVar := new(shared.ConfigGroupType)
	if !r.Type.IsUnknown() && !r.Type.IsNull() {
		*typeVar = shared.ConfigGroupType(r.Type.ValueString())
	} else {
		typeVar = nil
	}
	upgradeVersion := new(string)
	if !r.UpgradeVersion.IsUnknown() && !r.UpgradeVersion.IsNull() {
		*upgradeVersion = r.UpgradeVersion.ValueString()
	} else {
		upgradeVersion = nil
	}
	workerCount := new(float64)
	if !r.WorkerCount.IsUnknown() && !r.WorkerCount.IsNull() {
		*workerCount = r.WorkerCount.ValueFloat64()
	} else {
		workerCount = nil
	}
	workerRemoteAccess := new(bool)
	if !r.WorkerRemoteAccess.IsUnknown() && !r.WorkerRemoteAccess.IsNull() {
		*workerRemoteAccess = r.WorkerRemoteAccess.ValueBool()
	} else {
		workerRemoteAccess = nil
	}
	out := shared.ConfigGroup{
		Cloud:                   cloud,
		ConfigVersion:           configVersion,
		DeployingWorkerCount:    deployingWorkerCount,
		Description:             description,
		EstimatedIngestRate:     estimatedIngestRate,
		Git:                     git,
		ID:                      id,
		IncompatibleWorkerCount: incompatibleWorkerCount,
		Inherits:                inherits,
		IsFleet:                 isFleet,
		IsSearch:                isSearch,
		LookupDeployments:       lookupDeployments,
		Name:                    name,
		OnPrem:                  onPrem,
		Provisioned:             provisioned,
		Streamtags:              streamtags,
		Tags:                    tags,
		Type:                    typeVar,
		UpgradeVersion:          upgradeVersion,
		WorkerCount:             workerCount,
		WorkerRemoteAccess:      workerRemoteAccess,
	}

	return &out, diags
}
