// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &NotificationTargetResource{}
var _ resource.ResourceWithImportState = &NotificationTargetResource{}

func NewNotificationTargetResource() resource.Resource {
	return &NotificationTargetResource{}
}

// NotificationTargetResource defines the resource implementation.
type NotificationTargetResource struct {
	// Provider configured SDK client.
	client *sdk.CriblIo
}

// NotificationTargetResourceModel describes the resource data model.
type NotificationTargetResourceModel struct {
	ID              types.String             `tfsdk:"id"`
	PagerDutyTarget *tfTypes.PagerDutyTarget `queryParam:"inline" tfsdk:"pager_duty_target" tfPlanOnly:"true"`
	SlackTarget     *tfTypes.SlackTarget     `queryParam:"inline" tfsdk:"slack_target" tfPlanOnly:"true"`
	SMTPTarget      *tfTypes.SMTPTarget      `queryParam:"inline" tfsdk:"smtp_target" tfPlanOnly:"true"`
	SnsTarget       *tfTypes.SnsTarget       `queryParam:"inline" tfsdk:"sns_target" tfPlanOnly:"true"`
	WebhookTarget   *tfTypes.WebhookTarget   `queryParam:"inline" tfsdk:"webhook_target" tfPlanOnly:"true"`
}

func (r *NotificationTargetResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_notification_target"
}

func (r *NotificationTargetResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "NotificationTarget Resource",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Required:    true,
				Description: `Unique ID to DELETE`,
			},
			"pager_duty_target": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"class": schema.StringAttribute{
						Optional:    true,
						Description: `Optional, default class value`,
					},
					"component": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`logstream`),
						Description: `Optional, default component value. Default: "logstream"`,
					},
					"group": schema.StringAttribute{
						Optional:    true,
						Description: `Optional, default group value`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this notification target`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z0-9_-]+$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).String()),
						},
					},
					"routing_key": schema.StringAttribute{
						Required:    true,
						Description: `32-character integration key for an integration on a service or global ruleset`,
					},
					"severity": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`info`),
						Description: `Default value for message severity. Defaults to info. The __severity value, if set, will overwrite this. Default: "info"; must be one of ["info", "warning", "error", "critical"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"info",
								"warning",
								"error",
								"critical",
							),
						},
					},
					"system_fields": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards.`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "pager_duty"`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"pager_duty",
							),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("slack_target"),
						path.MatchRelative().AtParent().AtName("smtp_target"),
						path.MatchRelative().AtParent().AtName("sns_target"),
						path.MatchRelative().AtParent().AtName("webhook_target"),
					}...),
				},
			},
			"slack_target": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this notification target`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z0-9_-]+$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).String()),
						},
					},
					"system_fields": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards.`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "slack"`,
						Validators: []validator.String{
							stringvalidator.OneOf("slack"),
						},
					},
					"url": schema.StringAttribute{
						Required:    true,
						Description: `Slack's Incoming Webhook URL`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://[a-zA-Z0-9-.]+`), "must match pattern "+regexp.MustCompile(`^https?://[a-zA-Z0-9-.]+`).String()),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("pager_duty_target"),
						path.MatchRelative().AtParent().AtName("smtp_target"),
						path.MatchRelative().AtParent().AtName("sns_target"),
						path.MatchRelative().AtParent().AtName("webhook_target"),
					}...),
				},
			},
			"smtp_target": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"encryption_option": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`NONE`),
						Description: `Encryption method for SMTP. Default: "NONE"; must be one of ["NONE", "STARTTLS", "SSL"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"NONE",
								"STARTTLS",
								"SSL",
							),
						},
					},
					"from": schema.StringAttribute{
						Required:    true,
						Description: `Email address to send from`,
					},
					"host": schema.StringAttribute{
						Required:    true,
						Description: `SMTP server hostname`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this notification target`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z0-9_-]+$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).String()),
						},
					},
					"password": schema.StringAttribute{
						Optional:    true,
						Description: `SMTP authentication password`,
					},
					"port": schema.Int64Attribute{
						Required:    true,
						Description: `SMTP server port`,
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
					},
					"system_fields": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards.`,
					},
					"tls": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"max_version": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`TLSv1.3`),
								Description: `Maximum TLS version to accept. Default: "TLSv1.3"; must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"min_version": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`TLSv1.2`),
								Description: `Minimum TLS version to accept. Default: "TLSv1.2"; must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"TLSv1",
										"TLSv1.1",
										"TLSv1.2",
										"TLSv1.3",
									),
								},
							},
							"reject_unauthorized": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Whether to reject unauthorized certificates. Default: true`,
							},
						},
						Description: `TLS configuration options`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "smtp"`,
						Validators: []validator.String{
							stringvalidator.OneOf("smtp"),
						},
					},
					"username": schema.StringAttribute{
						Optional:    true,
						Description: `SMTP authentication username`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("pager_duty_target"),
						path.MatchRelative().AtParent().AtName("slack_target"),
						path.MatchRelative().AtParent().AtName("sns_target"),
						path.MatchRelative().AtParent().AtName("webhook_target"),
					}...),
				},
			},
			"sns_target": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"allowlist": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Wildcard list of allowed phone numbers. This is not enforced if the notification is sent to topic.`,
					},
					"assume_role_arn": schema.StringAttribute{
						Optional:    true,
						Description: `ARN of the role to assume`,
					},
					"assume_role_external_id": schema.StringAttribute{
						Optional:    true,
						Description: `External ID for role assumption`,
					},
					"aws_api_key": schema.StringAttribute{
						Optional:    true,
						Description: `AWS access key`,
					},
					"aws_authentication_method": schema.StringAttribute{
						Optional:    true,
						Description: `AWS authentication method. must be one of ["auto", "manual", "secret"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"auto",
								"manual",
								"secret",
							),
						},
					},
					"aws_secret_key": schema.StringAttribute{
						Optional:    true,
						Description: `AWS secret key`,
					},
					"destination_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`topic`),
						Description: `The type of destination to send notifications to. Default: "topic"; must be one of ["phoneNumber", "topic"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"phoneNumber",
								"topic",
							),
						},
					},
					"endpoint": schema.StringAttribute{
						Optional:    true,
						Description: `SNS endpoint URL`,
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this notification target`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z0-9_-]+$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).String()),
						},
					},
					"message_group_id": schema.StringAttribute{
						Optional:    true,
						Description: `Message group ID for FIFO topics`,
					},
					"phone_number": schema.StringAttribute{
						Optional:    true,
						Description: `The default phone number to send the notification to. This value can be overridden by the notification event __phoneNumber field.`,
					},
					"region": schema.StringAttribute{
						Required:    true,
						Description: `AWS region`,
					},
					"system_fields": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards.`,
					},
					"topic_arn": schema.StringAttribute{
						Optional:    true,
						Description: `The default ARN of the SNS topic to send notifications to`,
					},
					"topic_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`fifo`),
						Description: `Type of the topic selected in AWS SNS. Default: "fifo"; must be one of ["standard", "fifo"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"standard",
								"fifo",
							),
						},
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "sns"`,
						Validators: []validator.String{
							stringvalidator.OneOf("sns"),
						},
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("pager_duty_target"),
						path.MatchRelative().AtParent().AtName("slack_target"),
						path.MatchRelative().AtParent().AtName("smtp_target"),
						path.MatchRelative().AtParent().AtName("webhook_target"),
					}...),
				},
			},
			"webhook_target": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"auth_type": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`none`),
						Description: `Authentication method for the webhook. Default: "none"; must be one of ["none", "token", "basic"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"none",
								"token",
								"basic",
							),
						},
					},
					"format": schema.StringAttribute{
						Required:    true,
						Description: `Format of the webhook payload. must be one of ["ndjson", "json_array", "custom"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ndjson",
								"json_array",
								"custom",
							),
						},
					},
					"id": schema.StringAttribute{
						Required:    true,
						Description: `Unique ID for this notification target`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^[a-zA-Z0-9_-]+$`), "must match pattern "+regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).String()),
						},
					},
					"method": schema.StringAttribute{
						Required:    true,
						Description: `HTTP method to use for the webhook. must be one of ["POST", "PATCH", "PUT"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"POST",
								"PATCH",
								"PUT",
							),
						},
					},
					"password": schema.StringAttribute{
						Optional:    true,
						Description: `Basic authentication password`,
					},
					"system_fields": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
						Description: `Fields to automatically add to events, such as cribl_pipe. Supports wildcards.`,
					},
					"token": schema.StringAttribute{
						Optional:    true,
						Description: `Authentication token`,
					},
					"type": schema.StringAttribute{
						Required:    true,
						Description: `must be "webhook"`,
						Validators: []validator.String{
							stringvalidator.OneOf("webhook"),
						},
					},
					"url": schema.StringAttribute{
						Required:    true,
						Description: `URL to send the webhook to`,
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile(`^https?://.+`), "must match pattern "+regexp.MustCompile(`^https?://.+`).String()),
						},
					},
					"username": schema.StringAttribute{
						Optional:    true,
						Description: `Basic authentication username`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("pager_duty_target"),
						path.MatchRelative().AtParent().AtName("slack_target"),
						path.MatchRelative().AtParent().AtName("smtp_target"),
						path.MatchRelative().AtParent().AtName("sns_target"),
					}...),
				},
			},
		},
	}
}

func (r *NotificationTargetResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.CriblIo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.CriblIo, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *NotificationTargetResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *NotificationTargetResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToSharedNotificationTarget(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.NotificationTargets.CreateNotificationTarget(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsCreateNotificationTargetResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NotificationTargetResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *NotificationTargetResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	res, err := r.client.NotificationTargets.ListNotificationTarget(ctx)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsListNotificationTargetResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NotificationTargetResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *NotificationTargetResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateNotificationTargetByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.NotificationTargets.UpdateNotificationTargetByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsUpdateNotificationTargetByIDResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.NotificationTargets.ListNotificationTarget(ctx)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsListNotificationTargetResponseBody(ctx, res1.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NotificationTargetResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *NotificationTargetResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteNotificationTargetByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.NotificationTargets.DeleteNotificationTargetByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *NotificationTargetResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.AddError("Not Implemented", "No available import state operation is available for resource notification_target.")
}
