// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	speakeasy_boolplanmodifier "github.com/criblio/terraform-provider-criblio/internal/planmodifiers/boolplanmodifier"
	speakeasy_float64planmodifier "github.com/criblio/terraform-provider-criblio/internal/planmodifiers/float64planmodifier"
	speakeasy_int64planmodifier "github.com/criblio/terraform-provider-criblio/internal/planmodifiers/int64planmodifier"
	speakeasy_listplanmodifier "github.com/criblio/terraform-provider-criblio/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/criblio/terraform-provider-criblio/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/criblio/terraform-provider-criblio/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk"
	speakeasy_objectvalidators "github.com/criblio/terraform-provider-criblio/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/criblio/terraform-provider-criblio/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &CollectorResource{}
var _ resource.ResourceWithImportState = &CollectorResource{}

func NewCollectorResource() resource.Resource {
	return &CollectorResource{}
}

// CollectorResource defines the resource implementation.
type CollectorResource struct {
	// Provider configured SDK client.
	client *sdk.CriblIo
}

// CollectorResourceModel describes the resource data model.
type CollectorResourceModel struct {
	Environment               types.String                       `tfsdk:"environment"`
	GroupID                   types.String                       `tfsdk:"group_id"`
	ID                        types.String                       `queryParam:"style=form,explode=true,name=id" tfsdk:"id"`
	IgnoreGroupJobsLimit      types.Bool                         `tfsdk:"ignore_group_jobs_limit"`
	InputCollectorAzureBlob   *tfTypes.InputCollectorAzureBlob   `queryParam:"inline" tfsdk:"input_collector_azure_blob" tfPlanOnly:"true"`
	InputCollectorCriblLake   *tfTypes.InputCollectorCriblLake   `queryParam:"inline" tfsdk:"input_collector_cribl_lake" tfPlanOnly:"true"`
	InputCollectorDatabase    *tfTypes.InputCollectorDatabase    `queryParam:"inline" tfsdk:"input_collector_database" tfPlanOnly:"true"`
	InputCollectorGCS         *tfTypes.InputCollectorGCS         `queryParam:"inline" tfsdk:"input_collector_gcs" tfPlanOnly:"true"`
	InputCollectorHealthCheck *tfTypes.InputCollectorHealthCheck `queryParam:"inline" tfsdk:"input_collector_health_check" tfPlanOnly:"true"`
	InputCollectorRest        *tfTypes.InputCollectorRest        `queryParam:"inline" tfsdk:"input_collector_rest" tfPlanOnly:"true"`
	InputCollectorS3          *tfTypes.InputCollectorS3          `queryParam:"inline" tfsdk:"input_collector_s3" tfPlanOnly:"true"`
	InputCollectorScript      *tfTypes.InputCollectorScript      `queryParam:"inline" tfsdk:"input_collector_script" tfPlanOnly:"true"`
	InputCollectorSplunk      *tfTypes.InputCollectorSplunk      `queryParam:"inline" tfsdk:"input_collector_splunk" tfPlanOnly:"true"`
	ResumeOnBoot              types.Bool                         `tfsdk:"resume_on_boot"`
	TTL                       types.String                       `tfsdk:"ttl"`
	WorkerAffinity            types.Bool                         `tfsdk:"worker_affinity"`
}

func (r *CollectorResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_collector"
}

func (r *CollectorResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Collector Resource",
		Attributes: map[string]schema.Attribute{
			"environment": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
			},
			"group_id": schema.StringAttribute{
				Required:    true,
				Description: `The consumer group to which this instance belongs. Defaults to 'default'.`,
			},
			"id": schema.StringAttribute{
				Required:    true,
				Description: `The id of this collector instance`,
			},
			"ignore_group_jobs_limit": schema.BoolAttribute{
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: `Default: false`,
			},
			"input_collector_azure_blob": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["manual", "secret", "clientSecret", "clientCert"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"manual",
												"secret",
												"clientSecret",
												"clientCert",
											),
										},
									},
									"connection_string": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Azure storage account Connection String`,
									},
									"container_name": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Azure container to collect from`,
									},
									"extractors": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"expression": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `JavaScript expression to compute the value from the path`,
												},
												"key": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `Name of the extracted field`,
												},
												"pattern": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `Regex pattern to match paths (alternative to key/expression)`,
												},
											},
										},
									},
									"max_batch_size": schema.Int64Attribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Int64{
											speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
										},
										Validators: []validator.Int64{
											int64validator.AtLeast(1),
										},
									},
									"path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Directory where data will be collected`,
									},
									"recurse": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"storage_account_name": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "azureblob"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"azureblob",
									),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_cribl_lake": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"dataset": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Lake dataset to collect data from`,
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "cribllake"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"cribllake",
									),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_database": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"connection_id": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Select an existing Database Connection`,
									},
									"query": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Query string for selecting data from the database`,
									},
									"query_validation_enabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "database"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("database"),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_gcs": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["manual", "secret", "clientSecret", "clientCert"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"manual",
												"secret",
												"clientSecret",
												"clientCert",
											),
										},
									},
									"bucket": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `GCS Bucket from which to collect data`,
									},
									"extractors": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"expression": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `JavaScript expression to compute the value from the path`,
												},
												"key": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `Name of the extracted field`,
												},
												"pattern": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `Regex pattern to match paths (alternative to key/expression)`,
												},
											},
										},
									},
									"max_batch_size": schema.Int64Attribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Int64{
											speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
										},
										Validators: []validator.Int64{
											int64validator.AtLeast(1),
										},
									},
									"path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Directory where data will be collected`,
									},
									"recurse": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"service_account_credentials": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "gcs"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("gcs"),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_health_check": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"authentication": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret", "oauth", "oauthSecret", "google_oauth", "google_oauthSecret", "hmac"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"basicSecret",
												"token",
												"tokenSecret",
												"login",
												"loginSecret",
												"oauth",
												"oauthSecret",
												"google_oauth",
												"google_oauthSecret",
												"hmac",
											),
										},
									},
									"collect_method": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["get", "post", "post_with_body", "other"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"get",
												"post",
												"post_with_body",
												"other",
											),
										},
									},
									"collect_url": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `URL to use for the Collect operation`,
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"timeout": schema.Int64Attribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Int64{
											speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
										},
										Validators: []validator.Int64{
											int64validator.AtMost(1800),
										},
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "healthcheck"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf(
										"healthcheck",
									),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_rest": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"auth_header_expr": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Expression for auth header value`,
									},
									"auth_header_key": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Header key for authentication`,
									},
									"auth_request_headers": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
												"value": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
											},
										},
									},
									"auth_request_params": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
												"value": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
											},
										},
									},
									"authentication": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret", "oauth", "oauthSecret", "google_oauth", "google_oauthSecret", "hmac"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"basicSecret",
												"token",
												"tokenSecret",
												"login",
												"loginSecret",
												"oauth",
												"oauthSecret",
												"google_oauth",
												"google_oauthSecret",
												"hmac",
											),
										},
									},
									"capture_headers": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(false),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: false`,
									},
									"client_secret_param_name": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"collect_method": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["get", "post", "post_with_body", "other"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"get",
												"post",
												"post_with_body",
												"other",
											),
										},
									},
									"collect_request_headers": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
												"value": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
											},
										},
									},
									"collect_request_params": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
												"value": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
												},
											},
										},
									},
									"collect_url": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `URL to use for the Collect operation`,
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"decode_url": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(false),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: false`,
									},
									"disable_time_filter": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"discovery": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"discover_body": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"discover_data_field": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"discover_method": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `protocol used for http discovery, required for 'http' type. must be one of ["get", "post", "post_with_body", "other"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"get",
														"post",
														"post_with_body",
														"other",
													),
												},
											},
											"discover_request_headers": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.List{
													speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
												},
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													PlanModifiers: []planmodifier.Object{
														speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
													},
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															Computed: true,
															Optional: true,
															PlanModifiers: []planmodifier.String{
																speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
															},
														},
														"value": schema.StringAttribute{
															Computed: true,
															Optional: true,
															PlanModifiers: []planmodifier.String{
																speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
															},
														},
													},
												},
											},
											"discover_request_params": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.List{
													speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
												},
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													PlanModifiers: []planmodifier.Object{
														speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
													},
													Attributes: map[string]schema.Attribute{},
												},
											},
											"discover_type": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `Not Null; must be one of ["http", "json", "list", "none"]`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
													stringvalidator.OneOf(
														"http",
														"json",
														"list",
														"none",
													),
												},
											},
											"discover_url": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `URL to hit for rest type collectors, required for 'http' discoverType`,
											},
											"enable_discover_code": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"format_result_code": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"item_list": schema.ListAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.List{
													speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
												},
												ElementType: types.StringType,
												Description: `comma separated list of strings to return from discovery section required for 'list' discoverType`,
											},
											"manual_discover_result": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `json payload to return manually, required for 'json' discoverType`,
											},
											"pagination": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.Object{
													speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
												},
												Attributes: map[string]schema.Attribute{
													"attribute": schema.ListAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.List{
															speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
														},
														ElementType: types.StringType,
													},
													"last_page_expr": schema.StringAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
													},
													"limit": schema.Int64Attribute{
														Computed: true,
														Optional: true,
														Default:  int64default.StaticInt64(100),
														PlanModifiers: []planmodifier.Int64{
															speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
														},
														Description: `Default: 100`,
													},
													"limit_field": schema.StringAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
													},
													"max_pages": schema.Int64Attribute{
														Computed: true,
														Optional: true,
														Default:  int64default.StaticInt64(0),
														PlanModifiers: []planmodifier.Int64{
															speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
														},
														Description: `Default: 0`,
													},
													"offset": schema.Int64Attribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.Int64{
															speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
														},
													},
													"offset_field": schema.StringAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
													},
													"page_field": schema.StringAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
													},
													"size": schema.Int64Attribute{
														Computed: true,
														Optional: true,
														Default:  int64default.StaticInt64(50),
														PlanModifiers: []planmodifier.Int64{
															speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
														},
														Description: `Default: 50`,
													},
													"size_field": schema.StringAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
													},
													"total_record_field": schema.StringAttribute{
														Computed: true,
														Optional: true,
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
													},
													"type": schema.StringAttribute{
														Computed: true,
														Optional: true,
														Default:  stringdefault.StaticString(`none`),
														PlanModifiers: []planmodifier.String{
															speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
														},
														Description: `Default: "none"; must be one of ["none", "offset", "cursor", "page"]`,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"none",
																"offset",
																"cursor",
																"page",
															),
														},
													},
													"zero_indexed": schema.BoolAttribute{
														Computed: true,
														Optional: true,
														Default:  booldefault.StaticBool(false),
														PlanModifiers: []planmodifier.Bool{
															speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
														},
														Description: `Default: false`,
													},
												},
											},
										},
										Description: `Not Null`,
										Validators: []validator.Object{
											speakeasy_objectvalidators.NotNull(),
										},
									},
									"login_body": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Body content for login request`,
									},
									"login_url": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `URL for authentication login`,
									},
									"pagination": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"attribute": schema.ListAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.List{
													speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
												},
												ElementType: types.StringType,
											},
											"last_page_expr": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"limit": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												Default:  int64default.StaticInt64(100),
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 100`,
											},
											"limit_field": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"max_pages": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												Default:  int64default.StaticInt64(0),
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 0`,
											},
											"offset": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
											},
											"offset_field": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"page_field": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"size": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												Default:  int64default.StaticInt64(50),
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 50`,
											},
											"size_field": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"total_record_field": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"type": schema.StringAttribute{
												Computed: true,
												Optional: true,
												Default:  stringdefault.StaticString(`none`),
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `Default: "none"; must be one of ["none", "offset", "cursor", "page"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"none",
														"offset",
														"cursor",
														"page",
													),
												},
											},
											"zero_indexed": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
										},
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"retry_rules": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"codes": schema.ListAttribute{
												Computed: true,
												Optional: true,
												Default: listdefault.StaticValue(types.ListValueMust(types.Int64Type, []attr.Value{
													types.Int64Value(429),
													types.Int64Value(503),
												})),
												PlanModifiers: []planmodifier.List{
													speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
												},
												ElementType: types.Int64Type,
												Description: `Default: [429,503]`,
											},
											"enable_header": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(true),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: true`,
											},
											"interval": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												Default:  int64default.StaticInt64(1000),
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 1000`,
											},
											"limit": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												Default:  int64default.StaticInt64(5),
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 5`,
											},
											"max_interval_ms": schema.Int64Attribute{
												Computed: true,
												Optional: true,
												Default:  int64default.StaticInt64(20000),
												PlanModifiers: []planmodifier.Int64{
													speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 20000`,
											},
											"multiplier": schema.Float64Attribute{
												Computed: true,
												Optional: true,
												Default:  float64default.StaticFloat64(2),
												PlanModifiers: []planmodifier.Float64{
													speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
												},
												Description: `Default: 2`,
											},
											"retry_connect_reset": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"retry_connect_timeout": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"retry_header_name": schema.StringAttribute{
												Computed: true,
												Optional: true,
												Default:  stringdefault.StaticString(`retry-after`),
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `Default: "retry-after"`,
											},
											"type": schema.StringAttribute{
												Computed: true,
												Optional: true,
												Default:  stringdefault.StaticString(`backoff`),
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
												Description: `Default: "backoff"; must be one of ["backoff", "fixed"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"backoff",
														"fixed",
													),
												},
											},
										},
									},
									"safe_headers": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
									},
									"scheduling": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"state_tracking": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.Object{
													speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
												},
											},
										},
									},
									"timeout": schema.Int64Attribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Int64{
											speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
										},
										Validators: []validator.Int64{
											int64validator.AtMost(1800),
										},
									},
									"token": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"token_resp_attribute": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Attribute name for token in response`,
									},
									"token_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"use_round_robin_dns": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "rest"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("rest"),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_s3": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"aws_api_key": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"aws_authentication_method": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["auto", "manual", "secret"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"auto",
												"manual",
												"secret",
											),
										},
									},
									"aws_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"aws_secret_key": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"bucket": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `S3 Bucket from which to collect data`,
									},
									"extractors": schema.ListNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"expression": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `JavaScript expression to compute the value from the path`,
												},
												"key": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `Name of the extracted field`,
												},
												"pattern": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `Regex pattern to match paths (alternative to key/expression)`,
												},
											},
										},
									},
									"max_batch_size": schema.Int64Attribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Int64{
											speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
										},
										Validators: []validator.Int64{
											int64validator.AtLeast(1),
										},
									},
									"path": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Directory where data will be collected`,
									},
									"recurse": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"region": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `AWS region from which to retrieve data`,
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "s3"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("s3"),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_script": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"collect_script": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"discover_script": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"shell": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "script"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("script"),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_splunk": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"authentication": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret", "oauth", "oauthSecret", "google_oauth", "google_oauthSecret", "hmac"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"basicSecret",
												"token",
												"tokenSecret",
												"login",
												"loginSecret",
												"oauth",
												"oauthSecret",
												"google_oauth",
												"google_oauthSecret",
												"hmac",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"disable_time_filter": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"earliest": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Earliest time boundary for the search`,
									},
									"endpoint": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `REST API endpoint used to create a search`,
									},
									"handle_escaped_chars": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"latest": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Latest time boundary for the search`,
									},
									"output_mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `must be one of ["csv", "json"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"csv",
												"json",
											),
										},
									},
									"password": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"reject_unauthorized": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"search": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Splunk search query`,
									},
									"search_head": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Search head base URL`,
									},
									"timeout": schema.Int64Attribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Int64{
											speakeasy_int64planmodifier.SuppressDiff(speakeasy_int64planmodifier.ExplicitSuppress),
										},
										Validators: []validator.Int64{
											int64validator.AtMost(1800),
										},
									},
									"token": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"token_secret": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
									"use_round_robin_dns": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
									},
									"username": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
									},
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Not Null; must be "splunk"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("splunk"),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
					"environment": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Not Null`,
						Validators: []validator.String{
							speakeasy_stringvalidators.NotNull(),
						},
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"value": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.). Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.List{
											speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
										},
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(10000),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`0`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`collection`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString(`*/5 * * * *`),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed: true,
								Optional: true,
								Default:  float64default.StaticFloat64(1),
								PlanModifiers: []planmodifier.Float64{
									speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
								},
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(false),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(0),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`true`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`0`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`info`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed: true,
										Optional: true,
										Default:  float64default.StaticFloat64(1),
										PlanModifiers: []planmodifier.Float64{
											speakeasy_float64planmodifier.SuppressDiff(speakeasy_float64planmodifier.ExplicitSuppress),
										},
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`10MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`1MB`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`list`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed: true,
										Optional: true,
										Default:  booldefault.StaticBool(true),
										PlanModifiers: []planmodifier.Bool{
											speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
										},
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed: true,
												Optional: true,
												Default:  booldefault.StaticBool(false),
												PlanModifiers: []planmodifier.Bool{
													speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
												},
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
											"state_update_expression": schema.StringAttribute{
												Computed: true,
												Optional: true,
												PlanModifiers: []planmodifier.String{
													speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
												},
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed: true,
										Optional: true,
										Default:  stringdefault.StaticString(`relative`),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
										},
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								Default:  booldefault.StaticBool(true),
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString(`4h`),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_script"),
					}...),
				},
			},
			"resume_on_boot": schema.BoolAttribute{
				Computed:    true,
				Default:     booldefault.StaticBool(true),
				Description: `Default: true`,
			},
			"ttl": schema.StringAttribute{
				Computed: true,
				Default:  stringdefault.StaticString(`4h`),
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Default: "4h"`,
			},
			"worker_affinity": schema.BoolAttribute{
				Computed:    true,
				Default:     booldefault.StaticBool(false),
				Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
			},
		},
	}
}

func (r *CollectorResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.CriblIo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.CriblIo, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *CollectorResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *CollectorResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCreateSavedJobRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.CreateSavedJob(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsCreateSavedJobResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CollectorResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *CollectorResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetSavedJobByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.GetSavedJobByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSavedJobByIDResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CollectorResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *CollectorResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateCollectorByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.UpdateCollectorByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsUpdateCollectorByIDResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CollectorResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *CollectorResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteCollectorByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.DeleteCollectorByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *CollectorResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		GroupID string `json:"group_id"`
		ID      string `json:"id"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The import ID is not valid. It is expected to be a JSON object string with the format: '{"group_id": "myExistingGroupId", "id": "myExistingJobId"}': `+err.Error())
		return
	}

	if len(data.GroupID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field group_id is required but was not found in the json encoded ID. It's expected to be a value alike '"myExistingGroupId"`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("group_id"), data.GroupID)...)
	if len(data.ID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field id is required but was not found in the json encoded ID. It's expected to be a value alike '"myExistingJobId"`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), data.ID)...)
}
