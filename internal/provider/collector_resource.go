// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/float64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &CollectorResource{}
var _ resource.ResourceWithImportState = &CollectorResource{}

func NewCollectorResource() resource.Resource {
	return &CollectorResource{}
}

// CollectorResource defines the resource implementation.
type CollectorResource struct {
	// Provider configured SDK client.
	client *sdk.CriblIo
}

// CollectorResourceModel describes the resource data model.
type CollectorResourceModel struct {
	GroupID                   types.String                       `tfsdk:"group_id"`
	ID                        types.String                       `queryParam:"style=form,explode=true,name=id" tfsdk:"id"`
	InputCollectorAzureBlob   *tfTypes.InputCollectorAzureBlob   `queryParam:"inline" tfsdk:"input_collector_azure_blob" tfPlanOnly:"true"`
	InputCollectorCriblLake   *tfTypes.InputCollectorCriblLake   `queryParam:"inline" tfsdk:"input_collector_cribl_lake" tfPlanOnly:"true"`
	InputCollectorDatabase    *tfTypes.InputCollectorDatabase    `queryParam:"inline" tfsdk:"input_collector_database" tfPlanOnly:"true"`
	InputCollectorGCS         *tfTypes.InputCollectorGCS         `queryParam:"inline" tfsdk:"input_collector_gcs" tfPlanOnly:"true"`
	InputCollectorHealthCheck *tfTypes.InputCollectorHealthCheck `queryParam:"inline" tfsdk:"input_collector_health_check" tfPlanOnly:"true"`
	InputCollectorRest        *tfTypes.InputCollectorRest        `queryParam:"inline" tfsdk:"input_collector_rest" tfPlanOnly:"true"`
	InputCollectorS3          *tfTypes.InputCollectorS3          `queryParam:"inline" tfsdk:"input_collector_s3" tfPlanOnly:"true"`
	InputCollectorSplunk      *tfTypes.InputCollectorSplunk      `queryParam:"inline" tfsdk:"input_collector_splunk" tfPlanOnly:"true"`
	Items                     []map[string]jsontypes.Normalized  `tfsdk:"items"`
}

func (r *CollectorResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_collector"
}

func (r *CollectorResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Collector Resource",
		Attributes: map[string]schema.Attribute{
			"group_id": schema.StringAttribute{
				Required:    true,
				Description: `The consumer group to which this instance belongs. Defaults to 'default'.`,
			},
			"id": schema.StringAttribute{
				Required:    true,
				Description: `The id of this collector instance`,
			},
			"input_collector_azure_blob": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["manual", "secret", "clientSecret", "clientCert"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"manual",
												"secret",
												"clientSecret",
												"clientCert",
											),
										},
									},
									"connection_string": schema.StringAttribute{
										Optional:    true,
										Description: `Azure storage account Connection String`,
									},
									"container_name": schema.StringAttribute{
										Optional:    true,
										Description: `Azure container to collect from`,
									},
									"extractors": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
									"max_batch_size": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.AtLeast(1),
										},
									},
									"path": schema.StringAttribute{
										Optional:    true,
										Description: `Directory where data will be collected`,
									},
									"recurse": schema.BoolAttribute{
										Optional: true,
									},
									"storage_account_name": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "azureblob"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"azureblob",
									),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_cribl_lake": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"dataset": schema.StringAttribute{
										Optional:    true,
										Description: `Lake dataset to collect data from`,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "cribllake"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"cribllake",
									),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_database": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"connection_id": schema.StringAttribute{
										Optional:    true,
										Description: `Select an existing Database Connection`,
									},
									"query": schema.StringAttribute{
										Optional:    true,
										Description: `Query string for selecting data from the database`,
									},
									"query_validation_enabled": schema.BoolAttribute{
										Optional: true,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "database"`,
								Validators: []validator.String{
									stringvalidator.OneOf("database"),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_gcs": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_type": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["manual", "secret", "clientSecret", "clientCert"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"manual",
												"secret",
												"clientSecret",
												"clientCert",
											),
										},
									},
									"bucket": schema.StringAttribute{
										Optional:    true,
										Description: `GCS Bucket from which to collect data`,
									},
									"extractors": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
									"max_batch_size": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.AtLeast(1),
										},
									},
									"path": schema.StringAttribute{
										Optional:    true,
										Description: `Directory where data will be collected`,
									},
									"recurse": schema.BoolAttribute{
										Optional: true,
									},
									"service_account_credentials": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "gcs"`,
								Validators: []validator.String{
									stringvalidator.OneOf("gcs"),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_health_check": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"authentication": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret", "oauth", "oauthSecret", "google_oauth", "google_oauthSecret", "hmac"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"basicSecret",
												"token",
												"tokenSecret",
												"login",
												"loginSecret",
												"oauth",
												"oauthSecret",
												"google_oauth",
												"google_oauthSecret",
												"hmac",
											),
										},
									},
									"collect_method": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["get", "post", "post_with_body", "other"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"get",
												"post",
												"post_with_body",
												"other",
											),
										},
									},
									"collect_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL to use for the Collect operation`,
									},
									"credentials_secret": schema.StringAttribute{
										Optional: true,
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.AtMost(1800),
										},
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "healthcheck"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"healthcheck",
									),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_rest": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"auth_header_expr": schema.StringAttribute{
										Optional:    true,
										Description: `Expression for auth header value`,
									},
									"auth_header_key": schema.StringAttribute{
										Optional:    true,
										Description: `Header key for authentication`,
									},
									"auth_request_headers": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											},
										},
									},
									"auth_request_params": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											},
										},
									},
									"authentication": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret", "oauth", "oauthSecret", "google_oauth", "google_oauthSecret", "hmac"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"basicSecret",
												"token",
												"tokenSecret",
												"login",
												"loginSecret",
												"oauth",
												"oauthSecret",
												"google_oauth",
												"google_oauthSecret",
												"hmac",
											),
										},
									},
									"capture_headers": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Default: false`,
									},
									"client_secret_param_name": schema.StringAttribute{
										Optional: true,
									},
									"collect_method": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["get", "post", "post_with_body", "other"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"get",
												"post",
												"post_with_body",
												"other",
											),
										},
									},
									"collect_request_headers": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											},
										},
									},
									"collect_request_params": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Optional: true,
												},
												"value": schema.StringAttribute{
													Optional: true,
												},
											},
										},
									},
									"collect_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL to use for the Collect operation`,
									},
									"credentials_secret": schema.StringAttribute{
										Optional: true,
									},
									"decode_url": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(false),
										Description: `Default: false`,
									},
									"disable_time_filter": schema.BoolAttribute{
										Optional: true,
									},
									"discovery": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"discover_body": schema.StringAttribute{
												Optional: true,
											},
											"discover_data_field": schema.StringAttribute{
												Optional: true,
											},
											"discover_method": schema.StringAttribute{
												Optional:    true,
												Description: `must be one of ["get", "post", "post_with_body", "other"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"get",
														"post",
														"post_with_body",
														"other",
													),
												},
											},
											"discover_request_headers": schema.ListNestedAttribute{
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															Optional: true,
														},
														"value": schema.StringAttribute{
															Optional: true,
														},
													},
												},
											},
											"discover_request_params": schema.ListNestedAttribute{
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{},
												},
											},
											"discover_type": schema.StringAttribute{
												Optional:    true,
												Description: `must be "http"`,
												Validators: []validator.String{
													stringvalidator.OneOf("http"),
												},
											},
											"discover_url": schema.StringAttribute{
												Optional: true,
											},
											"enable_discover_code": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"format_result_code": schema.StringAttribute{
												Optional: true,
											},
											"item_list": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
											},
											"pagination": schema.SingleNestedAttribute{
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"attribute": schema.ListAttribute{
														Optional:    true,
														ElementType: types.StringType,
													},
													"last_page_expr": schema.StringAttribute{
														Optional: true,
													},
													"limit": schema.Int64Attribute{
														Computed:    true,
														Optional:    true,
														Default:     int64default.StaticInt64(100),
														Description: `Default: 100`,
													},
													"limit_field": schema.StringAttribute{
														Optional: true,
													},
													"max_pages": schema.Int64Attribute{
														Computed:    true,
														Optional:    true,
														Default:     int64default.StaticInt64(0),
														Description: `Default: 0`,
													},
													"offset": schema.Int64Attribute{
														Optional: true,
													},
													"offset_field": schema.StringAttribute{
														Optional: true,
													},
													"page_field": schema.StringAttribute{
														Optional: true,
													},
													"size": schema.Int64Attribute{
														Computed:    true,
														Optional:    true,
														Default:     int64default.StaticInt64(50),
														Description: `Default: 50`,
													},
													"size_field": schema.StringAttribute{
														Optional: true,
													},
													"total_record_field": schema.StringAttribute{
														Optional: true,
													},
													"type": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Default:     stringdefault.StaticString(`none`),
														Description: `Default: "none"; must be one of ["none", "offset", "cursor", "page"]`,
														Validators: []validator.String{
															stringvalidator.OneOf(
																"none",
																"offset",
																"cursor",
																"page",
															),
														},
													},
													"zero_indexed": schema.BoolAttribute{
														Computed:    true,
														Optional:    true,
														Default:     booldefault.StaticBool(false),
														Description: `Default: false`,
													},
												},
											},
										},
									},
									"login_body": schema.StringAttribute{
										Optional:    true,
										Description: `Body content for login request`,
									},
									"login_url": schema.StringAttribute{
										Optional:    true,
										Description: `URL for authentication login`,
									},
									"pagination": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"attribute": schema.ListAttribute{
												Optional:    true,
												ElementType: types.StringType,
											},
											"last_page_expr": schema.StringAttribute{
												Optional: true,
											},
											"limit": schema.Int64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     int64default.StaticInt64(100),
												Description: `Default: 100`,
											},
											"limit_field": schema.StringAttribute{
												Optional: true,
											},
											"max_pages": schema.Int64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     int64default.StaticInt64(0),
												Description: `Default: 0`,
											},
											"offset": schema.Int64Attribute{
												Optional: true,
											},
											"offset_field": schema.StringAttribute{
												Optional: true,
											},
											"page_field": schema.StringAttribute{
												Optional: true,
											},
											"size": schema.Int64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     int64default.StaticInt64(50),
												Description: `Default: 50`,
											},
											"size_field": schema.StringAttribute{
												Optional: true,
											},
											"total_record_field": schema.StringAttribute{
												Optional: true,
											},
											"type": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`none`),
												Description: `Default: "none"; must be one of ["none", "offset", "cursor", "page"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"none",
														"offset",
														"cursor",
														"page",
													),
												},
											},
											"zero_indexed": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
										},
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Optional: true,
									},
									"retry_rules": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"codes": schema.ListAttribute{
												Computed: true,
												Optional: true,
												Default: listdefault.StaticValue(types.ListValueMust(types.Int64Type, []attr.Value{
													types.Int64Value(429),
													types.Int64Value(503),
												})),
												ElementType: types.Int64Type,
												Description: `Default: [429,503]`,
											},
											"enable_header": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(true),
												Description: `Default: true`,
											},
											"interval": schema.Int64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     int64default.StaticInt64(1000),
												Description: `Default: 1000`,
											},
											"limit": schema.Int64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     int64default.StaticInt64(5),
												Description: `Default: 5`,
											},
											"max_interval_ms": schema.Int64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     int64default.StaticInt64(20000),
												Description: `Default: 20000`,
											},
											"multiplier": schema.Float64Attribute{
												Computed:    true,
												Optional:    true,
												Default:     float64default.StaticFloat64(2),
												Description: `Default: 2`,
											},
											"retry_connect_reset": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"retry_connect_timeout": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"retry_header_name": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`retry-after`),
												Description: `Default: "retry-after"`,
											},
											"type": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Default:     stringdefault.StaticString(`backoff`),
												Description: `Default: "backoff"; must be one of ["backoff", "fixed"]`,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"backoff",
														"fixed",
													),
												},
											},
										},
									},
									"safe_headers": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
									},
									"scheduling": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"state_tracking": schema.SingleNestedAttribute{
												Optional: true,
											},
										},
									},
									"timeout": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.AtMost(1800),
										},
									},
									"token": schema.StringAttribute{
										Optional: true,
									},
									"token_resp_attribute": schema.StringAttribute{
										Optional:    true,
										Description: `Attribute name for token in response`,
									},
									"token_secret": schema.StringAttribute{
										Optional: true,
									},
									"use_round_robin_dns": schema.BoolAttribute{
										Optional: true,
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "rest"`,
								Validators: []validator.String{
									stringvalidator.OneOf("rest"),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_s3": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"aws_api_key": schema.StringAttribute{
										Optional: true,
									},
									"aws_authentication_method": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["auto", "manual", "secret"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"auto",
												"manual",
												"secret",
											),
										},
									},
									"aws_secret": schema.StringAttribute{
										Optional: true,
									},
									"aws_secret_key": schema.StringAttribute{
										Optional: true,
									},
									"bucket": schema.StringAttribute{
										Optional:    true,
										Description: `S3 Bucket from which to collect data`,
									},
									"extractors": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
									"max_batch_size": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.AtLeast(1),
										},
									},
									"path": schema.StringAttribute{
										Optional:    true,
										Description: `Directory where data will be collected`,
									},
									"recurse": schema.BoolAttribute{
										Optional: true,
									},
									"region": schema.StringAttribute{
										Optional:    true,
										Description: `AWS region from which to retrieve data`,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "s3"`,
								Validators: []validator.String{
									stringvalidator.OneOf("s3"),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_splunk"),
					}...),
				},
			},
			"input_collector_splunk": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"collector": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"conf": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"authentication": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["none", "basic", "basicSecret", "token", "tokenSecret", "login", "loginSecret", "oauth", "oauthSecret", "google_oauth", "google_oauthSecret", "hmac"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"none",
												"basic",
												"basicSecret",
												"token",
												"tokenSecret",
												"login",
												"loginSecret",
												"oauth",
												"oauthSecret",
												"google_oauth",
												"google_oauthSecret",
												"hmac",
											),
										},
									},
									"credentials_secret": schema.StringAttribute{
										Optional: true,
									},
									"disable_time_filter": schema.BoolAttribute{
										Optional: true,
									},
									"earliest": schema.StringAttribute{
										Optional:    true,
										Description: `Earliest time boundary for the search`,
									},
									"endpoint": schema.StringAttribute{
										Optional:    true,
										Description: `REST API endpoint used to create a search`,
									},
									"handle_escaped_chars": schema.BoolAttribute{
										Optional: true,
									},
									"latest": schema.StringAttribute{
										Optional:    true,
										Description: `Latest time boundary for the search`,
									},
									"output_mode": schema.StringAttribute{
										Optional:    true,
										Description: `must be one of ["csv", "json"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"csv",
												"json",
											),
										},
									},
									"password": schema.StringAttribute{
										Optional: true,
									},
									"reject_unauthorized": schema.BoolAttribute{
										Optional: true,
									},
									"search": schema.StringAttribute{
										Optional:    true,
										Description: `Splunk search query`,
									},
									"search_head": schema.StringAttribute{
										Optional:    true,
										Description: `Search head base URL`,
									},
									"timeout": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.AtMost(1800),
										},
									},
									"token": schema.StringAttribute{
										Optional: true,
									},
									"token_secret": schema.StringAttribute{
										Optional: true,
									},
									"use_round_robin_dns": schema.BoolAttribute{
										Optional: true,
									},
									"username": schema.StringAttribute{
										Optional: true,
									},
								},
							},
							"type": schema.StringAttribute{
								Required:    true,
								Description: `must be "splunk"`,
								Validators: []validator.String{
									stringvalidator.OneOf("splunk"),
								},
							},
						},
					},
					"environment": schema.StringAttribute{
						Optional: true,
					},
					"id": schema.StringAttribute{
						Optional: true,
					},
					"ignore_group_jobs_limit": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `Default: false`,
					},
					"input": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"breaker_rulesets": schema.ListAttribute{
								Optional:    true,
								ElementType: types.StringType,
								Description: `A list of event-breaking rulesets that will be applied, in order, to the input data stream`,
							},
							"metadata": schema.ListNestedAttribute{
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"value": schema.StringAttribute{
											Required:    true,
											Description: `JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)`,
										},
									},
								},
								Description: `Fields to add to events from this input`,
							},
							"output": schema.StringAttribute{
								Optional:    true,
								Description: `Destination to send results to`,
							},
							"pipeline": schema.StringAttribute{
								Optional:    true,
								Description: `Pipeline to process results`,
							},
							"preprocess": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"args": schema.ListAttribute{
										Optional:    true,
										ElementType: types.StringType,
										Description: `Arguments to be added to the custom command`,
									},
									"command": schema.StringAttribute{
										Optional:    true,
										Description: `Command to feed the data through (via stdin) and process its output (stdout)`,
									},
									"disabled": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Default: true`,
									},
								},
							},
							"send_to_routes": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination. Default: true`,
							},
							"stale_channel_flush_ms": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(10000),
								Description: `How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000`,
								Validators: []validator.Float64{
									float64validator.Between(10, 43200000),
								},
							},
							"throttle_rate_per_sec": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`0`),
								Description: `Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"`,
								Validators: []validator.String{
									stringvalidator.RegexMatches(regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`), "must match pattern "+regexp.MustCompile(`^[\d.]+(\s[KMGTPEZYkmgtpezy][Bb])?$`).String()),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`collection`),
								Description: `Default: "collection"; must be "collection"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"collection",
									),
								},
							},
						},
					},
					"remove_fields": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Default: []`,
					},
					"resume_on_boot": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(true),
						Description: `Default: true`,
					},
					"saved_state": schema.SingleNestedAttribute{
						Optional:    true,
						Description: `Saved state for the collector`,
					},
					"schedule": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"cron_schedule": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString(`*/5 * * * *`),
								Description: `A cron schedule on which to run this job. Default: "*/5 * * * *"`,
							},
							"enabled": schema.BoolAttribute{
								Optional:    true,
								Description: `Enable to configure scheduling for this Collector`,
							},
							"max_concurrent_runs": schema.Float64Attribute{
								Computed:    true,
								Optional:    true,
								Default:     float64default.StaticFloat64(1),
								Description: `The maximum number of instances of this scheduled job that may be running at any time. Default: 1`,
								Validators: []validator.Float64{
									float64validator.AtLeast(1),
								},
							},
							"resume_missed": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(false),
								Description: `Resume missed scheduled runs. Default: false`,
							},
							"run": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"earliest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(0),
										Description: `Earliest time to collect data for the selected timezone. Default: 0`,
									},
									"expression": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`true`),
										Description: `A filter for tokens in the provided collect path and/or the events being collected. Default: "true"`,
									},
									"job_timeout": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`0`),
										Description: `Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time. Default: "0"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`\d+[sm]?$`), "must match pattern "+regexp.MustCompile(`\d+[sm]?$`).String()),
										},
									},
									"latest": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Latest time to collect data for the selected timezone. Default: 1`,
									},
									"log_level": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`info`),
										Description: `Level at which to set task logging. Default: "info"; must be one of ["error", "warn", "info", "debug", "silly"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"error",
												"warn",
												"info",
												"debug",
												"silly",
											),
										},
									},
									"max_task_reschedule": schema.Float64Attribute{
										Computed:    true,
										Optional:    true,
										Default:     float64default.StaticFloat64(1),
										Description: `Maximum number of times a task can be rescheduled. Default: 1`,
										Validators: []validator.Float64{
											float64validator.AtLeast(1),
										},
									},
									"max_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`10MB`),
										Description: `Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB, you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks. Default: "10MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"min_task_size": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`1MB`),
										Description: `Limits the bundle size for small tasks. For example, if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task. Default: "1MB"`,
										Validators: []validator.String{
											stringvalidator.RegexMatches(regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`), "must match pattern "+regexp.MustCompile(`^((\d*\.?\d+)((KB|MB|GB|TB|PB|EB|ZB|YB|kb|mb|gb|tb|pb|eb|zb|yb){1}))$`).String()),
										},
									},
									"mode": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`list`),
										Description: `Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job. Default: "list"; must be one of ["list", "preview", "run"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"list",
												"preview",
												"run",
											),
										},
									},
									"reschedule_dropped_tasks": schema.BoolAttribute{
										Computed:    true,
										Optional:    true,
										Default:     booldefault.StaticBool(true),
										Description: `Reschedule tasks that failed with non-fatal errors. Default: true`,
									},
									"state_tracking": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:    true,
												Optional:    true,
												Default:     booldefault.StaticBool(false),
												Description: `Default: false`,
											},
											"state_merge_expression": schema.StringAttribute{
												Optional: true,
											},
											"state_update_expression": schema.StringAttribute{
												Optional: true,
											},
										},
										Description: `State tracking configuration`,
									},
									"time_range_type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString(`relative`),
										Description: `Default: "relative"; must be one of ["relative", "absolute"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"relative",
												"absolute",
											),
										},
									},
									"time_warning": schema.SingleNestedAttribute{
										Optional:    true,
										Description: `Time warning configuration`,
									},
								},
							},
							"skippable": schema.BoolAttribute{
								Computed:    true,
								Optional:    true,
								Default:     booldefault.StaticBool(true),
								Description: `Skippable jobs can be delayed, up to their next run time, if the system is hitting concurrency limits. Default: true`,
							},
						},
						Description: `Configuration for a scheduled job`,
					},
					"streamtags": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						ElementType: types.StringType,
						Description: `Tags for filtering and grouping. Default: []`,
					},
					"ttl": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Default:     stringdefault.StaticString(`4h`),
						Description: `Default: "4h"`,
					},
					"worker_affinity": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `If enabled, tasks are created and run by the same Worker Node. Default: false`,
					},
				},
				Validators: []validator.Object{
					objectvalidator.ConflictsWith(path.Expressions{
						path.MatchRelative().AtParent().AtName("input_collector_azure_blob"),
						path.MatchRelative().AtParent().AtName("input_collector_cribl_lake"),
						path.MatchRelative().AtParent().AtName("input_collector_database"),
						path.MatchRelative().AtParent().AtName("input_collector_gcs"),
						path.MatchRelative().AtParent().AtName("input_collector_health_check"),
						path.MatchRelative().AtParent().AtName("input_collector_rest"),
						path.MatchRelative().AtParent().AtName("input_collector_s3"),
					}...),
				},
			},
			"items": schema.ListAttribute{
				Computed: true,
				ElementType: types.MapType{
					ElemType: jsontypes.NormalizedType{},
				},
			},
		},
	}
}

func (r *CollectorResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.CriblIo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.CriblIo, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *CollectorResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *CollectorResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCreateSavedJobRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.CreateSavedJob(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsCreateSavedJobResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CollectorResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *CollectorResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetSavedJobByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.GetSavedJobByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSavedJobByIDResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CollectorResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *CollectorResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateCollectorByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.UpdateCollectorByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil && res.Object.Items != nil && len(res.Object.Items) > 0) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedInputCollector(ctx, &res.Object.Items[0])...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetSavedJobByIDRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.SavedJobs.GetSavedJobByID(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSavedJobByIDResponseBody(ctx, res1.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *CollectorResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *CollectorResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteCollectorByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.SavedJobs.DeleteCollectorByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *CollectorResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		GroupID string `json:"group_id"`
		ID      string `json:"id"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The import ID is not valid. It is expected to be a JSON object string with the format: '{"group_id": "myExistingGroupId", "id": "myExistingJobId"}': `+err.Error())
		return
	}

	if len(data.GroupID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field group_id is required but was not found in the json encoded ID. It's expected to be a value alike '"myExistingGroupId"`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("group_id"), data.GroupID)...)
	if len(data.ID) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field id is required but was not found in the json encoded ID. It's expected to be a value alike '"myExistingJobId"`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), data.ID)...)
}
