// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk"
	"github.com/hashicorp/terraform-plugin-framework-validators/float64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &HybridGroupSystemSettingsResource{}
var _ resource.ResourceWithImportState = &HybridGroupSystemSettingsResource{}

func NewHybridGroupSystemSettingsResource() resource.Resource {
	return &HybridGroupSystemSettingsResource{}
}

// HybridGroupSystemSettingsResource defines the resource implementation.
type HybridGroupSystemSettingsResource struct {
	// Provider configured SDK client.
	client *sdk.CriblIo
}

// HybridGroupSystemSettingsResourceModel describes the resource data model.
type HybridGroupSystemSettingsResourceModel struct {
	API                  tfTypes.SystemSettingsConfAPI        `tfsdk:"api"`
	Backups              tfTypes.SystemSettingsConfBackups    `tfsdk:"backups"`
	CustomLogo           tfTypes.SystemSettingsConfCustomLogo `tfsdk:"custom_logo"`
	GroupID              types.String                         `tfsdk:"group_id"`
	Items                []tfTypes.SystemSettings             `tfsdk:"items"`
	Pii                  tfTypes.SystemSettingsConfPii        `tfsdk:"pii"`
	Proxy                tfTypes.SystemSettingsConfProxy      `tfsdk:"proxy"`
	Rollback             tfTypes.SystemSettingsConfRollback   `tfsdk:"rollback"`
	Shutdown             tfTypes.SystemSettingsConfShutdown   `tfsdk:"shutdown"`
	Sni                  tfTypes.SystemSettingsConfSni        `tfsdk:"sni"`
	Sockets              *tfTypes.SystemSettingsConfSockets   `tfsdk:"sockets"`
	System               tfTypes.SystemSettingsConfSystem     `tfsdk:"system"`
	TLS                  tfTypes.SystemSettingsConfTLS        `tfsdk:"tls"`
	UpgradeGroupSettings tfTypes.UpgradeGroupSettings         `tfsdk:"upgrade_group_settings"`
	UpgradeSettings      tfTypes.UpgradeSettings              `tfsdk:"upgrade_settings"`
	Workers              tfTypes.SystemSettingsConfWorkers    `tfsdk:"workers"`
}

func (r *HybridGroupSystemSettingsResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_hybrid_group_system_settings"
}

func (r *HybridGroupSystemSettingsResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "HybridGroupSystemSettings Resource",
		Attributes: map[string]schema.Attribute{
			"api": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"base_url": schema.StringAttribute{
						Optional: true,
					},
					"disable_api_cache": schema.BoolAttribute{
						Optional: true,
					},
					"disabled": schema.BoolAttribute{
						Required: true,
					},
					"headers": schema.SingleNestedAttribute{
						Optional: true,
					},
					"host": schema.StringAttribute{
						Required: true,
					},
					"idle_session_ttl": schema.Float64Attribute{
						Optional: true,
					},
					"listen_on_port": schema.BoolAttribute{
						Optional: true,
					},
					"login_rate_limit": schema.StringAttribute{
						Optional: true,
					},
					"port": schema.Float64Attribute{
						Required: true,
					},
					"protocol": schema.StringAttribute{
						Required: true,
					},
					"scripts": schema.BoolAttribute{
						Optional: true,
					},
					"sensitive_fields": schema.ListAttribute{
						Optional:    true,
						ElementType: types.StringType,
					},
					"ssl": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"ca_path": schema.StringAttribute{
								Optional: true,
							},
							"cert_path": schema.StringAttribute{
								Required: true,
							},
							"disabled": schema.BoolAttribute{
								Required: true,
							},
							"passphrase": schema.StringAttribute{
								Required: true,
							},
							"priv_key_path": schema.StringAttribute{
								Required: true,
							},
						},
					},
					"sso_rate_limit": schema.StringAttribute{
						Optional: true,
					},
					"worker_remote_access": schema.BoolAttribute{
						Required: true,
					},
				},
			},
			"backups": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"backup_persistence": schema.StringAttribute{
						Required: true,
					},
					"backups_directory": schema.StringAttribute{
						Required: true,
					},
				},
			},
			"custom_logo": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Required: true,
					},
					"logo_description": schema.StringAttribute{
						Required: true,
					},
					"logo_image": schema.StringAttribute{
						Required: true,
					},
				},
			},
			"group_id": schema.StringAttribute{
				Required:    true,
				Description: `The hybrid worker group to which this instance belongs. Defaults to 'defaultHybrid'.`,
			},
			"items": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"base_url": schema.StringAttribute{
									Computed: true,
								},
								"disable_api_cache": schema.BoolAttribute{
									Computed: true,
								},
								"disabled": schema.BoolAttribute{
									Computed: true,
								},
								"headers": schema.SingleNestedAttribute{
									Computed: true,
								},
								"host": schema.StringAttribute{
									Computed: true,
								},
								"idle_session_ttl": schema.Float64Attribute{
									Computed: true,
								},
								"listen_on_port": schema.BoolAttribute{
									Computed: true,
								},
								"login_rate_limit": schema.StringAttribute{
									Computed: true,
								},
								"port": schema.Float64Attribute{
									Computed: true,
								},
								"protocol": schema.StringAttribute{
									Computed: true,
								},
								"scripts": schema.BoolAttribute{
									Computed: true,
								},
								"sensitive_fields": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"ssl": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"ca_path": schema.StringAttribute{
											Computed: true,
										},
										"cert_path": schema.StringAttribute{
											Computed: true,
										},
										"disabled": schema.BoolAttribute{
											Computed: true,
										},
										"passphrase": schema.StringAttribute{
											Computed: true,
										},
										"priv_key_path": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"sso_rate_limit": schema.StringAttribute{
									Computed: true,
								},
								"worker_remote_access": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
						"auth": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"fallback": schema.BoolAttribute{
									Computed: true,
								},
								"fallback_bad_login": schema.BoolAttribute{
									Computed: true,
								},
								"filter_type": schema.StringAttribute{
									Computed: true,
								},
								"host": schema.StringAttribute{
									Computed: true,
								},
								"port": schema.Float64Attribute{
									Computed: true,
								},
								"ssl": schema.BoolAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["ldap", "splunk", "local", "saas", "saml", "openid"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"ldap",
											"splunk",
											"local",
											"saas",
											"saml",
											"openid",
										),
									},
								},
							},
						},
						"backups": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"backup_persistence": schema.StringAttribute{
									Computed: true,
								},
								"backups_directory": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"custom_logo": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"logo_description": schema.StringAttribute{
									Computed: true,
								},
								"logo_image": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"distributed": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"mode": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["single", "master", "worker", "edge", "managed-edge", "outpost"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"single",
											"master",
											"worker",
											"edge",
											"managed-edge",
											"outpost",
										),
									},
								},
							},
						},
						"fips": schema.BoolAttribute{
							Computed: true,
						},
						"git": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"auth_type": schema.StringAttribute{
									Computed: true,
								},
								"auto_action": schema.StringAttribute{
									Computed: true,
								},
								"auto_action_message": schema.StringAttribute{
									Computed: true,
								},
								"auto_action_schedule": schema.StringAttribute{
									Computed: true,
								},
								"branch": schema.StringAttribute{
									Computed: true,
								},
								"commit_deploy_single_action": schema.BoolAttribute{
									Computed: true,
								},
								"copilot_auto_git_commit_messages": schema.BoolAttribute{
									Computed: true,
								},
								"default_commit_message": schema.StringAttribute{
									Computed: true,
								},
								"git_ops": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["none", "pull", "push"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"none",
											"pull",
											"push",
										),
									},
								},
								"password": schema.StringAttribute{
									Computed: true,
								},
								"remote": schema.StringAttribute{
									Computed: true,
								},
								"ssh_key": schema.StringAttribute{
									Computed: true,
								},
								"strict_host_key_checking": schema.BoolAttribute{
									Computed: true,
								},
								"timeout": schema.Float64Attribute{
									Computed: true,
								},
								"user": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"job_limits": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"concurrent_job_limit": schema.Float64Attribute{
									Computed: true,
								},
								"concurrent_scheduled_job_limit": schema.Float64Attribute{
									Computed: true,
								},
								"concurrent_system_job_limit": schema.Float64Attribute{
									Computed: true,
								},
								"concurrent_system_task_limit": schema.Float64Attribute{
									Computed: true,
								},
								"concurrent_task_limit": schema.Float64Attribute{
									Computed: true,
								},
								"disable_tasks": schema.BoolAttribute{
									Computed: true,
								},
								"finished_job_artifacts_limit": schema.Float64Attribute{
									Computed: true,
								},
								"finished_task_artifacts_limit": schema.Float64Attribute{
									Computed: true,
								},
								"job_artifacts_reaper_period": schema.StringAttribute{
									Computed: true,
								},
								"job_timeout": schema.StringAttribute{
									Computed: true,
								},
								"max_task_perc": schema.Float64Attribute{
									Computed: true,
								},
								"scheduling_policy": schema.StringAttribute{
									Computed: true,
								},
								"task_heartbeat_period": schema.Float64Attribute{
									Computed: true,
								},
								"task_manifest_flush_period_ms": schema.Float64Attribute{
									Computed: true,
								},
								"task_manifest_max_buffer_size": schema.Float64Attribute{
									Computed: true,
								},
								"task_manifest_read_buffer_size": schema.StringAttribute{
									Computed: true,
								},
								"task_poll_timeout_ms": schema.Float64Attribute{
									Computed: true,
								},
							},
						},
						"limits": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"cpu_profile_ttl": schema.StringAttribute{
									Computed: true,
								},
								"edge_metrics_custom_expression": schema.StringAttribute{
									Computed: true,
								},
								"edge_metrics_mode": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["minimal", "basic", "all", "custom"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"minimal",
											"basic",
											"all",
											"custom",
										),
									},
								},
								"edge_nodes_count": schema.Float64Attribute{
									Computed: true,
								},
								"enable_metrics_persistence": schema.BoolAttribute{
									Computed: true,
								},
								"events_metadata_sources": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"lookup_max_size": schema.StringAttribute{
									Computed: true,
								},
								"lookup_max_total_size": schema.StringAttribute{
									Computed: true,
								},
								"max_metrics": schema.Float64Attribute{
									Computed: true,
								},
								"max_pq_size": schema.StringAttribute{
									Computed: true,
								},
								"metrics_directory": schema.StringAttribute{
									Computed: true,
								},
								"metrics_drop_list": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"metrics_fields_blacklist": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"metrics_gc_period": schema.StringAttribute{
									Computed: true,
								},
								"metrics_max_cardinality": schema.Float64Attribute{
									Computed: true,
								},
								"metrics_max_disk_space": schema.StringAttribute{
									Computed: true,
								},
								"metrics_never_drop_list": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"metrics_worker_id_blacklist": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"min_free_space": schema.StringAttribute{
									Computed: true,
								},
								"samples": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"max_size": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
						},
						"pii": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"enable_pii_detection": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
						"proxy": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"use_env_vars": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
						"redis_cache_limits": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"client_tracking_mechanism": schema.StringAttribute{
									Computed: true,
								},
								"enable_server_assist": schema.BoolAttribute{
									Computed: true,
								},
								"key_ttl_secs": schema.Float64Attribute{
									Computed: true,
								},
								"max_cache_size": schema.Float64Attribute{
									Computed: true,
								},
								"max_num_keys": schema.Float64Attribute{
									Computed: true,
								},
								"service_period_secs": schema.Float64Attribute{
									Computed: true,
								},
							},
						},
						"redis_limits": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"connections": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"disabled": schema.BoolAttribute{
											Computed: true,
										},
										"max_connections": schema.Float64Attribute{
											Computed: true,
										},
									},
								},
							},
						},
						"rollback": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"rollback_enabled": schema.BoolAttribute{
									Computed: true,
								},
								"rollback_retries": schema.Float64Attribute{
									Computed: true,
								},
								"rollback_timeout": schema.Float64Attribute{
									Computed: true,
								},
							},
						},
						"search_limits": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"compress_object_cache_artifacts": schema.BoolAttribute{
									Computed: true,
								},
								"field_summary_max_fields": schema.Float64Attribute{
									Computed: true,
								},
								"field_summary_max_nested_depth": schema.Float64Attribute{
									Computed: true,
								},
								"max_concurrent_searches": schema.Float64Attribute{
									Computed: true,
								},
								"max_executors_per_search": schema.Float64Attribute{
									Computed: true,
								},
								"max_results_per_search": schema.Float64Attribute{
									Computed: true,
								},
								"search_history_max_jobs": schema.Float64Attribute{
									Computed: true,
								},
								"search_queue_length": schema.Float64Attribute{
									Computed: true,
								},
								"warm_pool_size": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"number": schema.Float64Attribute{
											Computed: true,
											Validators: []validator.Float64{
												float64validator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("warm_pool_size_enum"),
												}...),
											},
										},
										"warm_pool_size_enum": schema.StringAttribute{
											Computed:    true,
											Description: `must be "auto"`,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("number"),
												}...),
												stringvalidator.OneOf("auto"),
											},
										},
									},
								},
								"write_only_provider_secrets": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
						"services_limits": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"connections": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"memory_limit": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"metrics": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"memory_limit": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"notifications": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"memory_limit": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
						},
						"shutdown": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"drain_timeout": schema.Float64Attribute{
									Computed: true,
								},
							},
						},
						"sni": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"disable_sni_routing": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
						"sockets": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"directory": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"system": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"intercom": schema.BoolAttribute{
									Computed: true,
								},
								"upgrade": schema.StringAttribute{
									Computed:    true,
									Description: `must be one of ["false", "api"]`,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"false",
											"api",
										),
									},
								},
							},
						},
						"tls": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"default_cipher_list": schema.StringAttribute{
									Computed: true,
								},
								"default_ecdh_curve": schema.StringAttribute{
									Computed: true,
								},
								"max_version": schema.StringAttribute{
									Computed: true,
								},
								"min_version": schema.StringAttribute{
									Computed: true,
								},
								"reject_unauthorized": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
						"upgrade_group_settings": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"is_rolling": schema.BoolAttribute{
									Computed: true,
								},
								"quantity": schema.Float64Attribute{
									Computed: true,
								},
								"retry_count": schema.Float64Attribute{
									Computed: true,
								},
								"retry_delay": schema.Float64Attribute{
									Computed: true,
								},
							},
						},
						"upgrade_settings": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"automatic_upgrade_check_period": schema.StringAttribute{
									Computed: true,
								},
								"disable_automatic_upgrade": schema.BoolAttribute{
									Computed: true,
								},
								"enable_legacy_edge_upgrade": schema.BoolAttribute{
									Computed: true,
								},
								"package_urls": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"package_hash_url": schema.StringAttribute{
												Computed: true,
											},
											"package_url": schema.StringAttribute{
												Computed: true,
											},
										},
									},
								},
								"upgrade_source": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"workers": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"count": schema.Float64Attribute{
									Computed: true,
								},
								"enable_heap_snapshots": schema.BoolAttribute{
									Computed: true,
								},
								"load_throttle_perc": schema.Float64Attribute{
									Computed: true,
								},
								"memory": schema.Float64Attribute{
									Computed: true,
								},
								"minimum": schema.Float64Attribute{
									Computed: true,
								},
								"startup_max_conns": schema.Float64Attribute{
									Computed: true,
								},
								"startup_throttle_timeout": schema.Float64Attribute{
									Computed: true,
								},
								"v8_single_thread": schema.BoolAttribute{
									Computed: true,
								},
							},
						},
					},
				},
			},
			"pii": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"enable_pii_detection": schema.BoolAttribute{
						Required: true,
					},
				},
			},
			"proxy": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"use_env_vars": schema.BoolAttribute{
						Required: true,
					},
				},
			},
			"rollback": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"rollback_enabled": schema.BoolAttribute{
						Required: true,
					},
					"rollback_retries": schema.Float64Attribute{
						Optional: true,
					},
					"rollback_timeout": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"shutdown": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"drain_timeout": schema.Float64Attribute{
						Required: true,
					},
				},
			},
			"sni": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"disable_sni_routing": schema.BoolAttribute{
						Required: true,
					},
				},
			},
			"sockets": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"directory": schema.StringAttribute{
						Optional: true,
					},
				},
			},
			"system": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"intercom": schema.BoolAttribute{
						Required: true,
					},
					"upgrade": schema.StringAttribute{
						Required:    true,
						Description: `must be one of ["false", "api"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"false",
								"api",
							),
						},
					},
				},
			},
			"tls": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"default_cipher_list": schema.StringAttribute{
						Required: true,
					},
					"default_ecdh_curve": schema.StringAttribute{
						Required: true,
					},
					"max_version": schema.StringAttribute{
						Required: true,
					},
					"min_version": schema.StringAttribute{
						Required: true,
					},
					"reject_unauthorized": schema.BoolAttribute{
						Required: true,
					},
				},
			},
			"upgrade_group_settings": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"is_rolling": schema.BoolAttribute{
						Optional: true,
					},
					"quantity": schema.Float64Attribute{
						Optional: true,
					},
					"retry_count": schema.Float64Attribute{
						Optional: true,
					},
					"retry_delay": schema.Float64Attribute{
						Optional: true,
					},
				},
			},
			"upgrade_settings": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"automatic_upgrade_check_period": schema.StringAttribute{
						Optional: true,
					},
					"disable_automatic_upgrade": schema.BoolAttribute{
						Required: true,
					},
					"enable_legacy_edge_upgrade": schema.BoolAttribute{
						Required: true,
					},
					"package_urls": schema.ListNestedAttribute{
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"package_hash_url": schema.StringAttribute{
									Optional: true,
								},
								"package_url": schema.StringAttribute{
									Required: true,
								},
							},
						},
					},
					"upgrade_source": schema.StringAttribute{
						Required: true,
					},
				},
			},
			"workers": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"count": schema.Float64Attribute{
						Required: true,
					},
					"enable_heap_snapshots": schema.BoolAttribute{
						Optional: true,
					},
					"load_throttle_perc": schema.Float64Attribute{
						Optional: true,
					},
					"memory": schema.Float64Attribute{
						Required: true,
					},
					"minimum": schema.Float64Attribute{
						Required: true,
					},
					"startup_max_conns": schema.Float64Attribute{
						Optional: true,
					},
					"startup_throttle_timeout": schema.Float64Attribute{
						Optional: true,
					},
					"v8_single_thread": schema.BoolAttribute{
						Optional: true,
					},
				},
			},
		},
	}
}

func (r *HybridGroupSystemSettingsResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.CriblIo)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.CriblIo, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *HybridGroupSystemSettingsResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *HybridGroupSystemSettingsResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateSystemSettingsConfRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.System.UpdateSystemSettingsConf(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsUpdateSystemSettingsConfResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetSystemSettingsConfRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.System.GetSystemSettingsConf(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSystemSettingsConfResponseBody(ctx, res1.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HybridGroupSystemSettingsResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *HybridGroupSystemSettingsResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetSystemSettingsConfRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.System.GetSystemSettingsConf(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSystemSettingsConfResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HybridGroupSystemSettingsResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *HybridGroupSystemSettingsResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateSystemSettingsConfRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.System.UpdateSystemSettingsConf(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsUpdateSystemSettingsConfResponseBody(ctx, res.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetSystemSettingsConfRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.System.GetSystemSettingsConf(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.Object != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromOperationsGetSystemSettingsConfResponseBody(ctx, res1.Object)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *HybridGroupSystemSettingsResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *HybridGroupSystemSettingsResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateSystemSettingsConfRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.System.UpdateSystemSettingsConf(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *HybridGroupSystemSettingsResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("group_id"), req.ID)...)
}
