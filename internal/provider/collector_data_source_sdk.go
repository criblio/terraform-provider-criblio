// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/operations"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *CollectorDataSourceModel) RefreshFromSharedInputCollector(ctx context.Context, resp *shared.InputCollector) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp.Collector.Conf == nil {
		r.Collector.Conf = nil
	} else {
		r.Collector.Conf = &tfTypes.InputCollectorConf{}
		if resp.Collector.Conf.Authentication != nil {
			r.Collector.Conf.Authentication = types.StringValue(string(*resp.Collector.Conf.Authentication))
		} else {
			r.Collector.Conf.Authentication = types.StringNull()
		}
		if resp.Collector.Conf.AuthType != nil {
			r.Collector.Conf.AuthType = types.StringValue(string(*resp.Collector.Conf.AuthType))
		} else {
			r.Collector.Conf.AuthType = types.StringNull()
		}
		r.Collector.Conf.AwsAPIKey = types.StringPointerValue(resp.Collector.Conf.AwsAPIKey)
		if resp.Collector.Conf.AwsAuthenticationMethod != nil {
			r.Collector.Conf.AwsAuthenticationMethod = types.StringValue(string(*resp.Collector.Conf.AwsAuthenticationMethod))
		} else {
			r.Collector.Conf.AwsAuthenticationMethod = types.StringNull()
		}
		r.Collector.Conf.AwsSecret = types.StringPointerValue(resp.Collector.Conf.AwsSecret)
		r.Collector.Conf.AwsSecretKey = types.StringPointerValue(resp.Collector.Conf.AwsSecretKey)
		r.Collector.Conf.Bucket = types.StringPointerValue(resp.Collector.Conf.Bucket)
		if resp.Collector.Conf.CollectMethod != nil {
			r.Collector.Conf.CollectMethod = types.StringValue(string(*resp.Collector.Conf.CollectMethod))
		} else {
			r.Collector.Conf.CollectMethod = types.StringNull()
		}
		r.Collector.Conf.CollectURL = types.StringPointerValue(resp.Collector.Conf.CollectURL)
		r.Collector.Conf.ConnectionID = types.StringPointerValue(resp.Collector.Conf.ConnectionID)
		r.Collector.Conf.ConnectionString = types.StringPointerValue(resp.Collector.Conf.ConnectionString)
		r.Collector.Conf.ContainerName = types.StringPointerValue(resp.Collector.Conf.ContainerName)
		r.Collector.Conf.CredentialsSecret = types.StringPointerValue(resp.Collector.Conf.CredentialsSecret)
		r.Collector.Conf.Dataset = types.StringPointerValue(resp.Collector.Conf.Dataset)
		r.Collector.Conf.DisableTimeFilter = types.BoolPointerValue(resp.Collector.Conf.DisableTimeFilter)
		r.Collector.Conf.Earliest = types.StringPointerValue(resp.Collector.Conf.Earliest)
		r.Collector.Conf.Endpoint = types.StringPointerValue(resp.Collector.Conf.Endpoint)
		r.Collector.Conf.HandleEscapedChars = types.BoolPointerValue(resp.Collector.Conf.HandleEscapedChars)
		r.Collector.Conf.Latest = types.StringPointerValue(resp.Collector.Conf.Latest)
		r.Collector.Conf.MaxBatchSize = types.Int64PointerValue(resp.Collector.Conf.MaxBatchSize)
		if resp.Collector.Conf.OutputMode != nil {
			r.Collector.Conf.OutputMode = types.StringValue(string(*resp.Collector.Conf.OutputMode))
		} else {
			r.Collector.Conf.OutputMode = types.StringNull()
		}
		r.Collector.Conf.Password = types.StringPointerValue(resp.Collector.Conf.Password)
		r.Collector.Conf.Path = types.StringPointerValue(resp.Collector.Conf.Path)
		r.Collector.Conf.Query = types.StringPointerValue(resp.Collector.Conf.Query)
		r.Collector.Conf.QueryValidationEnabled = types.BoolPointerValue(resp.Collector.Conf.QueryValidationEnabled)
		r.Collector.Conf.Recurse = types.BoolPointerValue(resp.Collector.Conf.Recurse)
		r.Collector.Conf.Region = types.StringPointerValue(resp.Collector.Conf.Region)
		r.Collector.Conf.RejectUnauthorized = types.BoolPointerValue(resp.Collector.Conf.RejectUnauthorized)
		r.Collector.Conf.Search = types.StringPointerValue(resp.Collector.Conf.Search)
		r.Collector.Conf.SearchHead = types.StringPointerValue(resp.Collector.Conf.SearchHead)
		r.Collector.Conf.ServiceAccountCredentials = types.StringPointerValue(resp.Collector.Conf.ServiceAccountCredentials)
		r.Collector.Conf.StorageAccountName = types.StringPointerValue(resp.Collector.Conf.StorageAccountName)
		r.Collector.Conf.Timeout = types.Int64PointerValue(resp.Collector.Conf.Timeout)
		r.Collector.Conf.Token = types.StringPointerValue(resp.Collector.Conf.Token)
		r.Collector.Conf.TokenSecret = types.StringPointerValue(resp.Collector.Conf.TokenSecret)
		r.Collector.Conf.Username = types.StringPointerValue(resp.Collector.Conf.Username)
		r.Collector.Conf.UseRoundRobinDNS = types.BoolPointerValue(resp.Collector.Conf.UseRoundRobinDNS)
	}
	r.Collector.Destructive = types.BoolPointerValue(resp.Collector.Destructive)
	r.Collector.Encoding = types.StringPointerValue(resp.Collector.Encoding)
	r.Collector.Type = types.StringValue(string(resp.Collector.Type))
	r.Environment = types.StringPointerValue(resp.Environment)
	r.ID = types.StringPointerValue(resp.ID)
	r.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.IgnoreGroupJobsLimit)
	if resp.Input == nil {
		r.Input = nil
	} else {
		r.Input = &tfTypes.InputCollectorInput{}
		r.Input.BreakerRulesets = make([]types.String, 0, len(resp.Input.BreakerRulesets))
		for _, v := range resp.Input.BreakerRulesets {
			r.Input.BreakerRulesets = append(r.Input.BreakerRulesets, types.StringValue(v))
		}
		r.Input.Metadata = []tfTypes.InputCollectorMetadatum{}

		for _, metadataItem := range resp.Input.Metadata {
			var metadata tfTypes.InputCollectorMetadatum

			metadata.Name = types.StringValue(metadataItem.Name)
			metadata.Value = types.StringValue(metadataItem.Value)

			r.Input.Metadata = append(r.Input.Metadata, metadata)
		}
		r.Input.Output = types.StringPointerValue(resp.Input.Output)
		r.Input.Pipeline = types.StringPointerValue(resp.Input.Pipeline)
		if resp.Input.Preprocess == nil {
			r.Input.Preprocess = nil
		} else {
			r.Input.Preprocess = &tfTypes.InputCollectorPreprocess{}
			r.Input.Preprocess.Args = make([]types.String, 0, len(resp.Input.Preprocess.Args))
			for _, v := range resp.Input.Preprocess.Args {
				r.Input.Preprocess.Args = append(r.Input.Preprocess.Args, types.StringValue(v))
			}
			r.Input.Preprocess.Command = types.StringPointerValue(resp.Input.Preprocess.Command)
			r.Input.Preprocess.Disabled = types.BoolPointerValue(resp.Input.Preprocess.Disabled)
		}
		r.Input.SendToRoutes = types.BoolPointerValue(resp.Input.SendToRoutes)
		r.Input.StaleChannelFlushMs = types.Float64PointerValue(resp.Input.StaleChannelFlushMs)
		r.Input.ThrottleRatePerSec = types.StringPointerValue(resp.Input.ThrottleRatePerSec)
		if resp.Input.Type != nil {
			r.Input.Type = types.StringValue(string(*resp.Input.Type))
		} else {
			r.Input.Type = types.StringNull()
		}
	}
	r.RemoveFields = make([]types.String, 0, len(resp.RemoveFields))
	for _, v := range resp.RemoveFields {
		r.RemoveFields = append(r.RemoveFields, types.StringValue(v))
	}
	r.ResumeOnBoot = types.BoolPointerValue(resp.ResumeOnBoot)
	if resp.Schedule == nil {
		r.Schedule = nil
	} else {
		r.Schedule = &tfTypes.InputCollectorSchedule{}
		r.Schedule.CronSchedule = types.StringPointerValue(resp.Schedule.CronSchedule)
		r.Schedule.Enabled = types.BoolPointerValue(resp.Schedule.Enabled)
		r.Schedule.MaxConcurrentRuns = types.Float64PointerValue(resp.Schedule.MaxConcurrentRuns)
		if resp.Schedule.Run == nil {
			r.Schedule.Run = nil
		} else {
			r.Schedule.Run = &tfTypes.InputCollectorRunSettings{}
			r.Schedule.Run.Earliest = types.Float64PointerValue(resp.Schedule.Run.Earliest)
			r.Schedule.Run.Expression = types.StringPointerValue(resp.Schedule.Run.Expression)
			r.Schedule.Run.JobTimeout = types.StringPointerValue(resp.Schedule.Run.JobTimeout)
			r.Schedule.Run.Latest = types.Float64PointerValue(resp.Schedule.Run.Latest)
			if resp.Schedule.Run.LogLevel != nil {
				r.Schedule.Run.LogLevel = types.StringValue(string(*resp.Schedule.Run.LogLevel))
			} else {
				r.Schedule.Run.LogLevel = types.StringNull()
			}
			r.Schedule.Run.MaxTaskReschedule = types.Float64PointerValue(resp.Schedule.Run.MaxTaskReschedule)
			r.Schedule.Run.MaxTaskSize = types.StringPointerValue(resp.Schedule.Run.MaxTaskSize)
			r.Schedule.Run.MinTaskSize = types.StringPointerValue(resp.Schedule.Run.MinTaskSize)
			r.Schedule.Run.Mode = types.StringPointerValue(resp.Schedule.Run.Mode)
			r.Schedule.Run.RescheduleDroppedTasks = types.BoolPointerValue(resp.Schedule.Run.RescheduleDroppedTasks)
			r.Schedule.Run.TimeRangeType = types.StringPointerValue(resp.Schedule.Run.TimeRangeType)
		}
		r.Schedule.Skippable = types.BoolPointerValue(resp.Schedule.Skippable)
	}
	r.Streamtags = make([]types.String, 0, len(resp.Streamtags))
	for _, v := range resp.Streamtags {
		r.Streamtags = append(r.Streamtags, types.StringValue(v))
	}
	r.TTL = types.StringPointerValue(resp.TTL)
	r.WorkerAffinity = types.BoolPointerValue(resp.WorkerAffinity)

	return diags
}

func (r *CollectorDataSourceModel) ToOperationsGetSavedJobByIDRequest(ctx context.Context) (*operations.GetSavedJobByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	var groupID string
	groupID = r.GroupID.ValueString()

	out := operations.GetSavedJobByIDRequest{
		ID:      id,
		GroupID: groupID,
	}

	return &out, diags
}
