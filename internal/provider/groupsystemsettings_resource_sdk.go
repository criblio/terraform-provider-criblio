// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/operations"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *GroupSystemSettingsResourceModel) RefreshFromOperationsGetSystemSettingsConfResponseBody(ctx context.Context, resp *operations.GetSystemSettingsConfResponseBody) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Items = []tfTypes.SystemSettings{}

		for _, itemsItem := range resp.Items {
			var items tfTypes.SystemSettings

			items.API.BaseURL = types.StringPointerValue(itemsItem.API.BaseURL)
			items.API.DisableAPICache = types.BoolPointerValue(itemsItem.API.DisableAPICache)
			items.API.Disabled = types.BoolValue(itemsItem.API.Disabled)
			if itemsItem.API.Headers == nil {
				items.API.Headers = nil
			} else {
				items.API.Headers = &tfTypes.SystemSettingsHeaders{}
			}
			items.API.Host = types.StringValue(itemsItem.API.Host)
			items.API.IdleSessionTTL = types.Float64PointerValue(itemsItem.API.IdleSessionTTL)
			items.API.ListenOnPort = types.BoolPointerValue(itemsItem.API.ListenOnPort)
			items.API.LoginRateLimit = types.StringPointerValue(itemsItem.API.LoginRateLimit)
			items.API.Port = types.Float64Value(itemsItem.API.Port)
			items.API.Protocol = types.StringValue(itemsItem.API.Protocol)
			items.API.Scripts = types.BoolPointerValue(itemsItem.API.Scripts)
			items.API.SensitiveFields = make([]types.String, 0, len(itemsItem.API.SensitiveFields))
			for _, v := range itemsItem.API.SensitiveFields {
				items.API.SensitiveFields = append(items.API.SensitiveFields, types.StringValue(v))
			}
			items.API.Ssl.CaPath = types.StringPointerValue(itemsItem.API.Ssl.CaPath)
			items.API.Ssl.CertPath = types.StringValue(itemsItem.API.Ssl.CertPath)
			items.API.Ssl.Disabled = types.BoolValue(itemsItem.API.Ssl.Disabled)
			items.API.Ssl.Passphrase = types.StringValue(itemsItem.API.Ssl.Passphrase)
			items.API.Ssl.PrivKeyPath = types.StringValue(itemsItem.API.Ssl.PrivKeyPath)
			items.API.SsoRateLimit = types.StringPointerValue(itemsItem.API.SsoRateLimit)
			items.API.WorkerRemoteAccess = types.BoolValue(itemsItem.API.WorkerRemoteAccess)
			items.Backups.BackupPersistence = types.StringValue(itemsItem.Backups.BackupPersistence)
			items.Backups.BackupsDirectory = types.StringValue(itemsItem.Backups.BackupsDirectory)
			items.CustomLogo.Enabled = types.BoolValue(itemsItem.CustomLogo.Enabled)
			items.CustomLogo.LogoDescription = types.StringValue(itemsItem.CustomLogo.LogoDescription)
			items.CustomLogo.LogoImage = types.StringValue(itemsItem.CustomLogo.LogoImage)
			items.Pii.EnablePiiDetection = types.BoolValue(itemsItem.Pii.EnablePiiDetection)
			items.Proxy.UseEnvVars = types.BoolValue(itemsItem.Proxy.UseEnvVars)
			items.Rollback.RollbackEnabled = types.BoolValue(itemsItem.Rollback.RollbackEnabled)
			items.Rollback.RollbackRetries = types.Float64PointerValue(itemsItem.Rollback.RollbackRetries)
			items.Rollback.RollbackTimeout = types.Float64PointerValue(itemsItem.Rollback.RollbackTimeout)
			items.Shutdown.DrainTimeout = types.Float64Value(itemsItem.Shutdown.DrainTimeout)
			items.Sni.DisableSNIRouting = types.BoolValue(itemsItem.Sni.DisableSNIRouting)
			if itemsItem.Sockets == nil {
				items.Sockets = nil
			} else {
				items.Sockets = &tfTypes.SystemSettingsSockets{}
				items.Sockets.Directory = types.StringPointerValue(itemsItem.Sockets.Directory)
			}
			items.System.Intercom = types.BoolValue(itemsItem.System.Intercom)
			items.System.Upgrade = types.StringValue(string(itemsItem.System.Upgrade))
			items.TLS.DefaultCipherList = types.StringValue(itemsItem.TLS.DefaultCipherList)
			items.TLS.DefaultEcdhCurve = types.StringValue(itemsItem.TLS.DefaultEcdhCurve)
			items.TLS.MaxVersion = types.StringValue(itemsItem.TLS.MaxVersion)
			items.TLS.MinVersion = types.StringValue(itemsItem.TLS.MinVersion)
			items.TLS.RejectUnauthorized = types.BoolValue(itemsItem.TLS.RejectUnauthorized)
			items.UpgradeGroupSettings.IsRolling = types.BoolPointerValue(itemsItem.UpgradeGroupSettings.IsRolling)
			items.UpgradeGroupSettings.Quantity = types.Float64PointerValue(itemsItem.UpgradeGroupSettings.Quantity)
			items.UpgradeGroupSettings.RetryCount = types.Float64PointerValue(itemsItem.UpgradeGroupSettings.RetryCount)
			items.UpgradeGroupSettings.RetryDelay = types.Float64PointerValue(itemsItem.UpgradeGroupSettings.RetryDelay)
			items.UpgradeSettings.AutomaticUpgradeCheckPeriod = types.StringPointerValue(itemsItem.UpgradeSettings.AutomaticUpgradeCheckPeriod)
			items.UpgradeSettings.DisableAutomaticUpgrade = types.BoolValue(itemsItem.UpgradeSettings.DisableAutomaticUpgrade)
			items.UpgradeSettings.EnableLegacyEdgeUpgrade = types.BoolValue(itemsItem.UpgradeSettings.EnableLegacyEdgeUpgrade)
			items.UpgradeSettings.PackageUrls = []tfTypes.UpgradePackageUrls{}

			for _, packageUrlsItem := range itemsItem.UpgradeSettings.PackageUrls {
				var packageUrls tfTypes.UpgradePackageUrls

				packageUrls.PackageHashURL = types.StringPointerValue(packageUrlsItem.PackageHashURL)
				packageUrls.PackageURL = types.StringValue(packageUrlsItem.PackageURL)

				items.UpgradeSettings.PackageUrls = append(items.UpgradeSettings.PackageUrls, packageUrls)
			}
			items.UpgradeSettings.UpgradeSource = types.StringValue(itemsItem.UpgradeSettings.UpgradeSource)
			items.Workers.Count = types.Float64Value(itemsItem.Workers.Count)
			items.Workers.EnableHeapSnapshots = types.BoolPointerValue(itemsItem.Workers.EnableHeapSnapshots)
			items.Workers.LoadThrottlePerc = types.Float64PointerValue(itemsItem.Workers.LoadThrottlePerc)
			items.Workers.Memory = types.Float64Value(itemsItem.Workers.Memory)
			items.Workers.Minimum = types.Float64Value(itemsItem.Workers.Minimum)
			items.Workers.StartupMaxConns = types.Float64PointerValue(itemsItem.Workers.StartupMaxConns)
			items.Workers.StartupThrottleTimeout = types.Float64PointerValue(itemsItem.Workers.StartupThrottleTimeout)
			items.Workers.V8SingleThread = types.BoolPointerValue(itemsItem.Workers.V8SingleThread)

			r.Items = append(r.Items, items)
		}
	}

	return diags
}

func (r *GroupSystemSettingsResourceModel) RefreshFromOperationsUpdateSystemSettingsConfResponseBody(ctx context.Context, resp *operations.UpdateSystemSettingsConfResponseBody) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Items = []tfTypes.SystemSettings{}

		for _, itemsItem := range resp.Items {
			var items tfTypes.SystemSettings

			items.API.BaseURL = types.StringPointerValue(itemsItem.API.BaseURL)
			items.API.DisableAPICache = types.BoolPointerValue(itemsItem.API.DisableAPICache)
			items.API.Disabled = types.BoolValue(itemsItem.API.Disabled)
			if itemsItem.API.Headers == nil {
				items.API.Headers = nil
			} else {
				items.API.Headers = &tfTypes.SystemSettingsHeaders{}
			}
			items.API.Host = types.StringValue(itemsItem.API.Host)
			items.API.IdleSessionTTL = types.Float64PointerValue(itemsItem.API.IdleSessionTTL)
			items.API.ListenOnPort = types.BoolPointerValue(itemsItem.API.ListenOnPort)
			items.API.LoginRateLimit = types.StringPointerValue(itemsItem.API.LoginRateLimit)
			items.API.Port = types.Float64Value(itemsItem.API.Port)
			items.API.Protocol = types.StringValue(itemsItem.API.Protocol)
			items.API.Scripts = types.BoolPointerValue(itemsItem.API.Scripts)
			items.API.SensitiveFields = make([]types.String, 0, len(itemsItem.API.SensitiveFields))
			for _, v := range itemsItem.API.SensitiveFields {
				items.API.SensitiveFields = append(items.API.SensitiveFields, types.StringValue(v))
			}
			items.API.Ssl.CaPath = types.StringPointerValue(itemsItem.API.Ssl.CaPath)
			items.API.Ssl.CertPath = types.StringValue(itemsItem.API.Ssl.CertPath)
			items.API.Ssl.Disabled = types.BoolValue(itemsItem.API.Ssl.Disabled)
			items.API.Ssl.Passphrase = types.StringValue(itemsItem.API.Ssl.Passphrase)
			items.API.Ssl.PrivKeyPath = types.StringValue(itemsItem.API.Ssl.PrivKeyPath)
			items.API.SsoRateLimit = types.StringPointerValue(itemsItem.API.SsoRateLimit)
			items.API.WorkerRemoteAccess = types.BoolValue(itemsItem.API.WorkerRemoteAccess)
			items.Auth.Fallback = types.BoolValue(itemsItem.Auth.Fallback)
			items.Auth.FallbackBadLogin = types.BoolValue(itemsItem.Auth.FallbackBadLogin)
			items.Auth.FilterType = types.StringPointerValue(itemsItem.Auth.FilterType)
			items.Auth.Host = types.StringValue(itemsItem.Auth.Host)
			items.Auth.Port = types.Float64Value(itemsItem.Auth.Port)
			items.Auth.Ssl = types.BoolValue(itemsItem.Auth.Ssl)
			items.Auth.Type = types.StringValue(string(itemsItem.Auth.Type))
			items.Backups.BackupPersistence = types.StringValue(itemsItem.Backups.BackupPersistence)
			items.Backups.BackupsDirectory = types.StringValue(itemsItem.Backups.BackupsDirectory)
			items.CustomLogo.Enabled = types.BoolValue(itemsItem.CustomLogo.Enabled)
			items.CustomLogo.LogoDescription = types.StringValue(itemsItem.CustomLogo.LogoDescription)
			items.CustomLogo.LogoImage = types.StringValue(itemsItem.CustomLogo.LogoImage)
			items.Distributed.Mode = types.StringValue(string(itemsItem.Distributed.Mode))
			items.Fips = types.BoolValue(itemsItem.Fips)
			items.Git.AuthType = types.StringPointerValue(itemsItem.Git.AuthType)
			items.Git.AutoAction = types.StringPointerValue(itemsItem.Git.AutoAction)
			items.Git.AutoActionMessage = types.StringPointerValue(itemsItem.Git.AutoActionMessage)
			items.Git.AutoActionSchedule = types.StringPointerValue(itemsItem.Git.AutoActionSchedule)
			items.Git.Branch = types.StringPointerValue(itemsItem.Git.Branch)
			items.Git.CommitDeploySingleAction = types.BoolPointerValue(itemsItem.Git.CommitDeploySingleAction)
			items.Git.CopilotAutoGitCommitMessages = types.BoolPointerValue(itemsItem.Git.CopilotAutoGitCommitMessages)
			items.Git.DefaultCommitMessage = types.StringPointerValue(itemsItem.Git.DefaultCommitMessage)
			if itemsItem.Git.GitOps != nil {
				items.Git.GitOps = types.StringValue(string(*itemsItem.Git.GitOps))
			} else {
				items.Git.GitOps = types.StringNull()
			}
			items.Git.Password = types.StringPointerValue(itemsItem.Git.Password)
			items.Git.Remote = types.StringPointerValue(itemsItem.Git.Remote)
			items.Git.SSHKey = types.StringPointerValue(itemsItem.Git.SSHKey)
			items.Git.StrictHostKeyChecking = types.BoolPointerValue(itemsItem.Git.StrictHostKeyChecking)
			items.Git.Timeout = types.Float64PointerValue(itemsItem.Git.Timeout)
			items.Git.User = types.StringPointerValue(itemsItem.Git.User)
			items.JobLimits.ConcurrentJobLimit = types.Float64Value(itemsItem.JobLimits.ConcurrentJobLimit)
			items.JobLimits.ConcurrentScheduledJobLimit = types.Float64Value(itemsItem.JobLimits.ConcurrentScheduledJobLimit)
			items.JobLimits.ConcurrentSystemJobLimit = types.Float64Value(itemsItem.JobLimits.ConcurrentSystemJobLimit)
			items.JobLimits.ConcurrentSystemTaskLimit = types.Float64Value(itemsItem.JobLimits.ConcurrentSystemTaskLimit)
			items.JobLimits.ConcurrentTaskLimit = types.Float64Value(itemsItem.JobLimits.ConcurrentTaskLimit)
			items.JobLimits.DisableTasks = types.BoolPointerValue(itemsItem.JobLimits.DisableTasks)
			items.JobLimits.FinishedJobArtifactsLimit = types.Float64Value(itemsItem.JobLimits.FinishedJobArtifactsLimit)
			items.JobLimits.FinishedTaskArtifactsLimit = types.Float64Value(itemsItem.JobLimits.FinishedTaskArtifactsLimit)
			items.JobLimits.JobArtifactsReaperPeriod = types.StringValue(itemsItem.JobLimits.JobArtifactsReaperPeriod)
			items.JobLimits.JobTimeout = types.StringValue(itemsItem.JobLimits.JobTimeout)
			items.JobLimits.MaxTaskPerc = types.Float64Value(itemsItem.JobLimits.MaxTaskPerc)
			items.JobLimits.SchedulingPolicy = types.StringValue(itemsItem.JobLimits.SchedulingPolicy)
			items.JobLimits.TaskHeartbeatPeriod = types.Float64Value(itemsItem.JobLimits.TaskHeartbeatPeriod)
			items.JobLimits.TaskManifestFlushPeriodMs = types.Float64Value(itemsItem.JobLimits.TaskManifestFlushPeriodMs)
			items.JobLimits.TaskManifestMaxBufferSize = types.Float64Value(itemsItem.JobLimits.TaskManifestMaxBufferSize)
			items.JobLimits.TaskManifestReadBufferSize = types.StringValue(itemsItem.JobLimits.TaskManifestReadBufferSize)
			items.JobLimits.TaskPollTimeoutMs = types.Float64Value(itemsItem.JobLimits.TaskPollTimeoutMs)
			items.Limits.CPUProfileTTL = types.StringValue(itemsItem.Limits.CPUProfileTTL)
			items.Limits.EdgeMetricsCustomExpression = types.StringPointerValue(itemsItem.Limits.EdgeMetricsCustomExpression)
			if itemsItem.Limits.EdgeMetricsMode != nil {
				items.Limits.EdgeMetricsMode = types.StringValue(string(*itemsItem.Limits.EdgeMetricsMode))
			} else {
				items.Limits.EdgeMetricsMode = types.StringNull()
			}
			items.Limits.EdgeNodesCount = types.Float64PointerValue(itemsItem.Limits.EdgeNodesCount)
			items.Limits.EnableMetricsPersistence = types.BoolValue(itemsItem.Limits.EnableMetricsPersistence)
			items.Limits.EventsMetadataSources = make([]types.String, 0, len(itemsItem.Limits.EventsMetadataSources))
			for _, v := range itemsItem.Limits.EventsMetadataSources {
				items.Limits.EventsMetadataSources = append(items.Limits.EventsMetadataSources, types.StringValue(v))
			}
			items.Limits.LookupMaxSize = types.StringPointerValue(itemsItem.Limits.LookupMaxSize)
			items.Limits.LookupMaxTotalSize = types.StringPointerValue(itemsItem.Limits.LookupMaxTotalSize)
			items.Limits.MaxMetrics = types.Float64PointerValue(itemsItem.Limits.MaxMetrics)
			items.Limits.MaxPQSize = types.StringPointerValue(itemsItem.Limits.MaxPQSize)
			items.Limits.MetricsDirectory = types.StringValue(itemsItem.Limits.MetricsDirectory)
			items.Limits.MetricsDropList = make([]types.String, 0, len(itemsItem.Limits.MetricsDropList))
			for _, v := range itemsItem.Limits.MetricsDropList {
				items.Limits.MetricsDropList = append(items.Limits.MetricsDropList, types.StringValue(v))
			}
			items.Limits.MetricsFieldsBlacklist = make([]types.String, 0, len(itemsItem.Limits.MetricsFieldsBlacklist))
			for _, v := range itemsItem.Limits.MetricsFieldsBlacklist {
				items.Limits.MetricsFieldsBlacklist = append(items.Limits.MetricsFieldsBlacklist, types.StringValue(v))
			}
			items.Limits.MetricsGCPeriod = types.StringValue(itemsItem.Limits.MetricsGCPeriod)
			items.Limits.MetricsMaxCardinality = types.Float64PointerValue(itemsItem.Limits.MetricsMaxCardinality)
			items.Limits.MetricsMaxDiskSpace = types.StringPointerValue(itemsItem.Limits.MetricsMaxDiskSpace)
			items.Limits.MetricsNeverDropList = make([]types.String, 0, len(itemsItem.Limits.MetricsNeverDropList))
			for _, v := range itemsItem.Limits.MetricsNeverDropList {
				items.Limits.MetricsNeverDropList = append(items.Limits.MetricsNeverDropList, types.StringValue(v))
			}
			items.Limits.MetricsWorkerIDBlacklist = make([]types.String, 0, len(itemsItem.Limits.MetricsWorkerIDBlacklist))
			for _, v := range itemsItem.Limits.MetricsWorkerIDBlacklist {
				items.Limits.MetricsWorkerIDBlacklist = append(items.Limits.MetricsWorkerIDBlacklist, types.StringValue(v))
			}
			items.Limits.MinFreeSpace = types.StringValue(itemsItem.Limits.MinFreeSpace)
			items.Limits.Samples.MaxSize = types.StringValue(itemsItem.Limits.Samples.MaxSize)
			items.Pii.EnablePiiDetection = types.BoolValue(itemsItem.Pii.EnablePiiDetection)
			items.Proxy.UseEnvVars = types.BoolValue(itemsItem.Proxy.UseEnvVars)
			items.RedisCacheLimits.ClientTrackingMechanism = types.StringPointerValue(itemsItem.RedisCacheLimits.ClientTrackingMechanism)
			items.RedisCacheLimits.EnableServerAssist = types.BoolPointerValue(itemsItem.RedisCacheLimits.EnableServerAssist)
			items.RedisCacheLimits.KeyTTLSecs = types.Float64PointerValue(itemsItem.RedisCacheLimits.KeyTTLSecs)
			items.RedisCacheLimits.MaxCacheSize = types.Float64PointerValue(itemsItem.RedisCacheLimits.MaxCacheSize)
			items.RedisCacheLimits.MaxNumKeys = types.Float64PointerValue(itemsItem.RedisCacheLimits.MaxNumKeys)
			items.RedisCacheLimits.ServicePeriodSecs = types.Float64PointerValue(itemsItem.RedisCacheLimits.ServicePeriodSecs)
			items.RedisLimits.Connections.Disabled = types.BoolPointerValue(itemsItem.RedisLimits.Connections.Disabled)
			items.RedisLimits.Connections.MaxConnections = types.Float64PointerValue(itemsItem.RedisLimits.Connections.MaxConnections)
			items.Rollback.RollbackEnabled = types.BoolValue(itemsItem.Rollback.RollbackEnabled)
			items.Rollback.RollbackRetries = types.Float64PointerValue(itemsItem.Rollback.RollbackRetries)
			items.Rollback.RollbackTimeout = types.Float64PointerValue(itemsItem.Rollback.RollbackTimeout)
			items.SearchLimits.CompressObjectCacheArtifacts = types.BoolValue(itemsItem.SearchLimits.CompressObjectCacheArtifacts)
			items.SearchLimits.FieldSummaryMaxFields = types.Float64Value(itemsItem.SearchLimits.FieldSummaryMaxFields)
			items.SearchLimits.FieldSummaryMaxNestedDepth = types.Float64Value(itemsItem.SearchLimits.FieldSummaryMaxNestedDepth)
			items.SearchLimits.MaxConcurrentSearches = types.Float64Value(itemsItem.SearchLimits.MaxConcurrentSearches)
			items.SearchLimits.MaxExecutorsPerSearch = types.Float64Value(itemsItem.SearchLimits.MaxExecutorsPerSearch)
			items.SearchLimits.MaxResultsPerSearch = types.Float64Value(itemsItem.SearchLimits.MaxResultsPerSearch)
			items.SearchLimits.SearchHistoryMaxJobs = types.Float64Value(itemsItem.SearchLimits.SearchHistoryMaxJobs)
			items.SearchLimits.SearchQueueLength = types.Float64Value(itemsItem.SearchLimits.SearchQueueLength)
			if itemsItem.SearchLimits.WarmPoolSize.Number != nil {
				items.SearchLimits.WarmPoolSize.Number = types.Float64PointerValue(itemsItem.SearchLimits.WarmPoolSize.Number)
			}
			if itemsItem.SearchLimits.WarmPoolSize.WarmPoolSizeEnum != nil {
				if itemsItem.SearchLimits.WarmPoolSize.WarmPoolSizeEnum != nil {
					items.SearchLimits.WarmPoolSize.WarmPoolSizeEnum = types.StringValue(string(*itemsItem.SearchLimits.WarmPoolSize.WarmPoolSizeEnum))
				} else {
					items.SearchLimits.WarmPoolSize.WarmPoolSizeEnum = types.StringNull()
				}
			}
			items.SearchLimits.WriteOnlyProviderSecrets = types.BoolValue(itemsItem.SearchLimits.WriteOnlyProviderSecrets)
			items.ServicesLimits.Connections.MemoryLimit = types.StringValue(itemsItem.ServicesLimits.Connections.MemoryLimit)
			items.ServicesLimits.Metrics.MemoryLimit = types.StringValue(itemsItem.ServicesLimits.Metrics.MemoryLimit)
			items.ServicesLimits.Notifications.MemoryLimit = types.StringValue(itemsItem.ServicesLimits.Notifications.MemoryLimit)
			items.Shutdown.DrainTimeout = types.Float64Value(itemsItem.Shutdown.DrainTimeout)
			items.Sni.DisableSNIRouting = types.BoolValue(itemsItem.Sni.DisableSNIRouting)
			if itemsItem.Sockets == nil {
				items.Sockets = nil
			} else {
				items.Sockets = &tfTypes.SystemSettingsSockets{}
				items.Sockets.Directory = types.StringPointerValue(itemsItem.Sockets.Directory)
			}
			items.System.Intercom = types.BoolValue(itemsItem.System.Intercom)
			items.System.Upgrade = types.StringValue(string(itemsItem.System.Upgrade))
			items.TLS.DefaultCipherList = types.StringValue(itemsItem.TLS.DefaultCipherList)
			items.TLS.DefaultEcdhCurve = types.StringValue(itemsItem.TLS.DefaultEcdhCurve)
			items.TLS.MaxVersion = types.StringValue(itemsItem.TLS.MaxVersion)
			items.TLS.MinVersion = types.StringValue(itemsItem.TLS.MinVersion)
			items.TLS.RejectUnauthorized = types.BoolValue(itemsItem.TLS.RejectUnauthorized)
			items.UpgradeGroupSettings.IsRolling = types.BoolPointerValue(itemsItem.UpgradeGroupSettings.IsRolling)
			items.UpgradeGroupSettings.Quantity = types.Float64PointerValue(itemsItem.UpgradeGroupSettings.Quantity)
			items.UpgradeGroupSettings.RetryCount = types.Float64PointerValue(itemsItem.UpgradeGroupSettings.RetryCount)
			items.UpgradeGroupSettings.RetryDelay = types.Float64PointerValue(itemsItem.UpgradeGroupSettings.RetryDelay)
			items.UpgradeSettings.AutomaticUpgradeCheckPeriod = types.StringPointerValue(itemsItem.UpgradeSettings.AutomaticUpgradeCheckPeriod)
			items.UpgradeSettings.DisableAutomaticUpgrade = types.BoolValue(itemsItem.UpgradeSettings.DisableAutomaticUpgrade)
			items.UpgradeSettings.EnableLegacyEdgeUpgrade = types.BoolValue(itemsItem.UpgradeSettings.EnableLegacyEdgeUpgrade)
			items.UpgradeSettings.PackageUrls = []tfTypes.UpgradePackageUrls{}

			for _, packageUrlsItem := range itemsItem.UpgradeSettings.PackageUrls {
				var packageUrls tfTypes.UpgradePackageUrls

				packageUrls.PackageHashURL = types.StringPointerValue(packageUrlsItem.PackageHashURL)
				packageUrls.PackageURL = types.StringValue(packageUrlsItem.PackageURL)

				items.UpgradeSettings.PackageUrls = append(items.UpgradeSettings.PackageUrls, packageUrls)
			}
			items.UpgradeSettings.UpgradeSource = types.StringValue(itemsItem.UpgradeSettings.UpgradeSource)
			items.Workers.Count = types.Float64Value(itemsItem.Workers.Count)
			items.Workers.EnableHeapSnapshots = types.BoolPointerValue(itemsItem.Workers.EnableHeapSnapshots)
			items.Workers.LoadThrottlePerc = types.Float64PointerValue(itemsItem.Workers.LoadThrottlePerc)
			items.Workers.Memory = types.Float64Value(itemsItem.Workers.Memory)
			items.Workers.Minimum = types.Float64Value(itemsItem.Workers.Minimum)
			items.Workers.StartupMaxConns = types.Float64PointerValue(itemsItem.Workers.StartupMaxConns)
			items.Workers.StartupThrottleTimeout = types.Float64PointerValue(itemsItem.Workers.StartupThrottleTimeout)
			items.Workers.V8SingleThread = types.BoolPointerValue(itemsItem.Workers.V8SingleThread)

			r.Items = append(r.Items, items)
		}
	}

	return diags
}

func (r *GroupSystemSettingsResourceModel) ToOperationsGetSystemSettingsConfRequest(ctx context.Context) (*operations.GetSystemSettingsConfRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var groupID string
	groupID = r.GroupID.ValueString()

	out := operations.GetSystemSettingsConfRequest{
		GroupID: groupID,
	}

	return &out, diags
}

func (r *GroupSystemSettingsResourceModel) ToOperationsUpdateSystemSettingsConfRequest(ctx context.Context) (*operations.UpdateSystemSettingsConfRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var groupID string
	groupID = r.GroupID.ValueString()

	systemSettingsConf, systemSettingsConfDiags := r.ToSharedSystemSettingsConf(ctx)
	diags.Append(systemSettingsConfDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateSystemSettingsConfRequest{
		GroupID:            groupID,
		SystemSettingsConf: *systemSettingsConf,
	}

	return &out, diags
}

func (r *GroupSystemSettingsResourceModel) ToSharedSystemSettingsConf(ctx context.Context) (*shared.SystemSettingsConf, diag.Diagnostics) {
	var diags diag.Diagnostics

	baseURL := new(string)
	if !r.API.BaseURL.IsUnknown() && !r.API.BaseURL.IsNull() {
		*baseURL = r.API.BaseURL.ValueString()
	} else {
		baseURL = nil
	}
	disableAPICache := new(bool)
	if !r.API.DisableAPICache.IsUnknown() && !r.API.DisableAPICache.IsNull() {
		*disableAPICache = r.API.DisableAPICache.ValueBool()
	} else {
		disableAPICache = nil
	}
	var disabled bool
	disabled = r.API.Disabled.ValueBool()

	var headers *shared.SystemSettingsConfHeaders
	if r.API.Headers != nil {
		headers = &shared.SystemSettingsConfHeaders{}
	}
	var host string
	host = r.API.Host.ValueString()

	idleSessionTTL := new(float64)
	if !r.API.IdleSessionTTL.IsUnknown() && !r.API.IdleSessionTTL.IsNull() {
		*idleSessionTTL = r.API.IdleSessionTTL.ValueFloat64()
	} else {
		idleSessionTTL = nil
	}
	listenOnPort := new(bool)
	if !r.API.ListenOnPort.IsUnknown() && !r.API.ListenOnPort.IsNull() {
		*listenOnPort = r.API.ListenOnPort.ValueBool()
	} else {
		listenOnPort = nil
	}
	loginRateLimit := new(string)
	if !r.API.LoginRateLimit.IsUnknown() && !r.API.LoginRateLimit.IsNull() {
		*loginRateLimit = r.API.LoginRateLimit.ValueString()
	} else {
		loginRateLimit = nil
	}
	var port float64
	port = r.API.Port.ValueFloat64()

	var protocol string
	protocol = r.API.Protocol.ValueString()

	scripts := new(bool)
	if !r.API.Scripts.IsUnknown() && !r.API.Scripts.IsNull() {
		*scripts = r.API.Scripts.ValueBool()
	} else {
		scripts = nil
	}
	sensitiveFields := make([]string, 0, len(r.API.SensitiveFields))
	for sensitiveFieldsIndex := range r.API.SensitiveFields {
		sensitiveFields = append(sensitiveFields, r.API.SensitiveFields[sensitiveFieldsIndex].ValueString())
	}
	caPath := new(string)
	if !r.API.Ssl.CaPath.IsUnknown() && !r.API.Ssl.CaPath.IsNull() {
		*caPath = r.API.Ssl.CaPath.ValueString()
	} else {
		caPath = nil
	}
	var certPath string
	certPath = r.API.Ssl.CertPath.ValueString()

	var disabled1 bool
	disabled1 = r.API.Ssl.Disabled.ValueBool()

	var passphrase string
	passphrase = r.API.Ssl.Passphrase.ValueString()

	var privKeyPath string
	privKeyPath = r.API.Ssl.PrivKeyPath.ValueString()

	ssl := shared.SystemSettingsConfSsl{
		CaPath:      caPath,
		CertPath:    certPath,
		Disabled:    disabled1,
		Passphrase:  passphrase,
		PrivKeyPath: privKeyPath,
	}
	ssoRateLimit := new(string)
	if !r.API.SsoRateLimit.IsUnknown() && !r.API.SsoRateLimit.IsNull() {
		*ssoRateLimit = r.API.SsoRateLimit.ValueString()
	} else {
		ssoRateLimit = nil
	}
	var workerRemoteAccess bool
	workerRemoteAccess = r.API.WorkerRemoteAccess.ValueBool()

	api := shared.SystemSettingsConfAPI{
		BaseURL:            baseURL,
		DisableAPICache:    disableAPICache,
		Disabled:           disabled,
		Headers:            headers,
		Host:               host,
		IdleSessionTTL:     idleSessionTTL,
		ListenOnPort:       listenOnPort,
		LoginRateLimit:     loginRateLimit,
		Port:               port,
		Protocol:           protocol,
		Scripts:            scripts,
		SensitiveFields:    sensitiveFields,
		Ssl:                ssl,
		SsoRateLimit:       ssoRateLimit,
		WorkerRemoteAccess: workerRemoteAccess,
	}
	var backupPersistence string
	backupPersistence = r.Backups.BackupPersistence.ValueString()

	var backupsDirectory string
	backupsDirectory = r.Backups.BackupsDirectory.ValueString()

	backups := shared.SystemSettingsConfBackups{
		BackupPersistence: backupPersistence,
		BackupsDirectory:  backupsDirectory,
	}
	var enabled bool
	enabled = r.CustomLogo.Enabled.ValueBool()

	var logoDescription string
	logoDescription = r.CustomLogo.LogoDescription.ValueString()

	var logoImage string
	logoImage = r.CustomLogo.LogoImage.ValueString()

	customLogo := shared.SystemSettingsConfCustomLogo{
		Enabled:         enabled,
		LogoDescription: logoDescription,
		LogoImage:       logoImage,
	}
	var enablePiiDetection bool
	enablePiiDetection = r.Pii.EnablePiiDetection.ValueBool()

	pii := shared.SystemSettingsConfPii{
		EnablePiiDetection: enablePiiDetection,
	}
	var useEnvVars bool
	useEnvVars = r.Proxy.UseEnvVars.ValueBool()

	proxy := shared.SystemSettingsConfProxy{
		UseEnvVars: useEnvVars,
	}
	var rollbackEnabled bool
	rollbackEnabled = r.Rollback.RollbackEnabled.ValueBool()

	rollbackRetries := new(float64)
	if !r.Rollback.RollbackRetries.IsUnknown() && !r.Rollback.RollbackRetries.IsNull() {
		*rollbackRetries = r.Rollback.RollbackRetries.ValueFloat64()
	} else {
		rollbackRetries = nil
	}
	rollbackTimeout := new(float64)
	if !r.Rollback.RollbackTimeout.IsUnknown() && !r.Rollback.RollbackTimeout.IsNull() {
		*rollbackTimeout = r.Rollback.RollbackTimeout.ValueFloat64()
	} else {
		rollbackTimeout = nil
	}
	rollback := shared.SystemSettingsConfRollback{
		RollbackEnabled: rollbackEnabled,
		RollbackRetries: rollbackRetries,
		RollbackTimeout: rollbackTimeout,
	}
	var drainTimeout float64
	drainTimeout = r.Shutdown.DrainTimeout.ValueFloat64()

	shutdown := shared.SystemSettingsConfShutdown{
		DrainTimeout: drainTimeout,
	}
	var disableSNIRouting bool
	disableSNIRouting = r.Sni.DisableSNIRouting.ValueBool()

	sni := shared.SystemSettingsConfSni{
		DisableSNIRouting: disableSNIRouting,
	}
	var sockets *shared.SystemSettingsConfSockets
	if r.Sockets != nil {
		directory := new(string)
		if !r.Sockets.Directory.IsUnknown() && !r.Sockets.Directory.IsNull() {
			*directory = r.Sockets.Directory.ValueString()
		} else {
			directory = nil
		}
		sockets = &shared.SystemSettingsConfSockets{
			Directory: directory,
		}
	}
	var intercom bool
	intercom = r.System.Intercom.ValueBool()

	upgrade := shared.SystemSettingsConfUpgrade(r.System.Upgrade.ValueString())
	system := shared.SystemSettingsConfSystem{
		Intercom: intercom,
		Upgrade:  upgrade,
	}
	var defaultCipherList string
	defaultCipherList = r.TLS.DefaultCipherList.ValueString()

	var defaultEcdhCurve string
	defaultEcdhCurve = r.TLS.DefaultEcdhCurve.ValueString()

	var maxVersion string
	maxVersion = r.TLS.MaxVersion.ValueString()

	var minVersion string
	minVersion = r.TLS.MinVersion.ValueString()

	var rejectUnauthorized bool
	rejectUnauthorized = r.TLS.RejectUnauthorized.ValueBool()

	tls := shared.SystemSettingsConfTLS{
		DefaultCipherList:  defaultCipherList,
		DefaultEcdhCurve:   defaultEcdhCurve,
		MaxVersion:         maxVersion,
		MinVersion:         minVersion,
		RejectUnauthorized: rejectUnauthorized,
	}
	isRolling := new(bool)
	if !r.UpgradeGroupSettings.IsRolling.IsUnknown() && !r.UpgradeGroupSettings.IsRolling.IsNull() {
		*isRolling = r.UpgradeGroupSettings.IsRolling.ValueBool()
	} else {
		isRolling = nil
	}
	quantity := new(float64)
	if !r.UpgradeGroupSettings.Quantity.IsUnknown() && !r.UpgradeGroupSettings.Quantity.IsNull() {
		*quantity = r.UpgradeGroupSettings.Quantity.ValueFloat64()
	} else {
		quantity = nil
	}
	retryCount := new(float64)
	if !r.UpgradeGroupSettings.RetryCount.IsUnknown() && !r.UpgradeGroupSettings.RetryCount.IsNull() {
		*retryCount = r.UpgradeGroupSettings.RetryCount.ValueFloat64()
	} else {
		retryCount = nil
	}
	retryDelay := new(float64)
	if !r.UpgradeGroupSettings.RetryDelay.IsUnknown() && !r.UpgradeGroupSettings.RetryDelay.IsNull() {
		*retryDelay = r.UpgradeGroupSettings.RetryDelay.ValueFloat64()
	} else {
		retryDelay = nil
	}
	upgradeGroupSettings := shared.UpgradeGroupSettings{
		IsRolling:  isRolling,
		Quantity:   quantity,
		RetryCount: retryCount,
		RetryDelay: retryDelay,
	}
	automaticUpgradeCheckPeriod := new(string)
	if !r.UpgradeSettings.AutomaticUpgradeCheckPeriod.IsUnknown() && !r.UpgradeSettings.AutomaticUpgradeCheckPeriod.IsNull() {
		*automaticUpgradeCheckPeriod = r.UpgradeSettings.AutomaticUpgradeCheckPeriod.ValueString()
	} else {
		automaticUpgradeCheckPeriod = nil
	}
	var disableAutomaticUpgrade bool
	disableAutomaticUpgrade = r.UpgradeSettings.DisableAutomaticUpgrade.ValueBool()

	var enableLegacyEdgeUpgrade bool
	enableLegacyEdgeUpgrade = r.UpgradeSettings.EnableLegacyEdgeUpgrade.ValueBool()

	packageUrls := make([]shared.UpgradePackageUrls, 0, len(r.UpgradeSettings.PackageUrls))
	for packageUrlsIndex := range r.UpgradeSettings.PackageUrls {
		packageHashURL := new(string)
		if !r.UpgradeSettings.PackageUrls[packageUrlsIndex].PackageHashURL.IsUnknown() && !r.UpgradeSettings.PackageUrls[packageUrlsIndex].PackageHashURL.IsNull() {
			*packageHashURL = r.UpgradeSettings.PackageUrls[packageUrlsIndex].PackageHashURL.ValueString()
		} else {
			packageHashURL = nil
		}
		var packageURL string
		packageURL = r.UpgradeSettings.PackageUrls[packageUrlsIndex].PackageURL.ValueString()

		packageUrls = append(packageUrls, shared.UpgradePackageUrls{
			PackageHashURL: packageHashURL,
			PackageURL:     packageURL,
		})
	}
	var upgradeSource string
	upgradeSource = r.UpgradeSettings.UpgradeSource.ValueString()

	upgradeSettings := shared.UpgradeSettings{
		AutomaticUpgradeCheckPeriod: automaticUpgradeCheckPeriod,
		DisableAutomaticUpgrade:     disableAutomaticUpgrade,
		EnableLegacyEdgeUpgrade:     enableLegacyEdgeUpgrade,
		PackageUrls:                 packageUrls,
		UpgradeSource:               upgradeSource,
	}
	var count float64
	count = r.Workers.Count.ValueFloat64()

	enableHeapSnapshots := new(bool)
	if !r.Workers.EnableHeapSnapshots.IsUnknown() && !r.Workers.EnableHeapSnapshots.IsNull() {
		*enableHeapSnapshots = r.Workers.EnableHeapSnapshots.ValueBool()
	} else {
		enableHeapSnapshots = nil
	}
	loadThrottlePerc := new(float64)
	if !r.Workers.LoadThrottlePerc.IsUnknown() && !r.Workers.LoadThrottlePerc.IsNull() {
		*loadThrottlePerc = r.Workers.LoadThrottlePerc.ValueFloat64()
	} else {
		loadThrottlePerc = nil
	}
	var memory float64
	memory = r.Workers.Memory.ValueFloat64()

	var minimum float64
	minimum = r.Workers.Minimum.ValueFloat64()

	startupMaxConns := new(float64)
	if !r.Workers.StartupMaxConns.IsUnknown() && !r.Workers.StartupMaxConns.IsNull() {
		*startupMaxConns = r.Workers.StartupMaxConns.ValueFloat64()
	} else {
		startupMaxConns = nil
	}
	startupThrottleTimeout := new(float64)
	if !r.Workers.StartupThrottleTimeout.IsUnknown() && !r.Workers.StartupThrottleTimeout.IsNull() {
		*startupThrottleTimeout = r.Workers.StartupThrottleTimeout.ValueFloat64()
	} else {
		startupThrottleTimeout = nil
	}
	v8SingleThread := new(bool)
	if !r.Workers.V8SingleThread.IsUnknown() && !r.Workers.V8SingleThread.IsNull() {
		*v8SingleThread = r.Workers.V8SingleThread.ValueBool()
	} else {
		v8SingleThread = nil
	}
	workers := shared.SystemSettingsConfWorkers{
		Count:                  count,
		EnableHeapSnapshots:    enableHeapSnapshots,
		LoadThrottlePerc:       loadThrottlePerc,
		Memory:                 memory,
		Minimum:                minimum,
		StartupMaxConns:        startupMaxConns,
		StartupThrottleTimeout: startupThrottleTimeout,
		V8SingleThread:         v8SingleThread,
	}
	out := shared.SystemSettingsConf{
		API:                  api,
		Backups:              backups,
		CustomLogo:           customLogo,
		Pii:                  pii,
		Proxy:                proxy,
		Rollback:             rollback,
		Shutdown:             shutdown,
		Sni:                  sni,
		Sockets:              sockets,
		System:               system,
		TLS:                  tls,
		UpgradeGroupSettings: upgradeGroupSettings,
		UpgradeSettings:      upgradeSettings,
		Workers:              workers,
	}

	return &out, diags
}
