// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	tfTypes "github.com/criblio/terraform-provider-criblio/internal/provider/types"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/operations"
	"github.com/criblio/terraform-provider-criblio/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *CollectorResourceModel) RefreshFromSharedInputCollector(ctx context.Context, resp *shared.InputCollector) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp.Collector.Conf == nil {
		r.Collector.Conf = nil
	} else {
		r.Collector.Conf = &tfTypes.InputCollectorConf{}
		if resp.Collector.Conf.Authentication != nil {
			r.Collector.Conf.Authentication = types.StringValue(string(*resp.Collector.Conf.Authentication))
		} else {
			r.Collector.Conf.Authentication = types.StringNull()
		}
		if resp.Collector.Conf.AuthType != nil {
			r.Collector.Conf.AuthType = types.StringValue(string(*resp.Collector.Conf.AuthType))
		} else {
			r.Collector.Conf.AuthType = types.StringNull()
		}
		r.Collector.Conf.AwsAPIKey = types.StringPointerValue(resp.Collector.Conf.AwsAPIKey)
		if resp.Collector.Conf.AwsAuthenticationMethod != nil {
			r.Collector.Conf.AwsAuthenticationMethod = types.StringValue(string(*resp.Collector.Conf.AwsAuthenticationMethod))
		} else {
			r.Collector.Conf.AwsAuthenticationMethod = types.StringNull()
		}
		r.Collector.Conf.AwsSecret = types.StringPointerValue(resp.Collector.Conf.AwsSecret)
		r.Collector.Conf.AwsSecretKey = types.StringPointerValue(resp.Collector.Conf.AwsSecretKey)
		r.Collector.Conf.Bucket = types.StringPointerValue(resp.Collector.Conf.Bucket)
		if resp.Collector.Conf.CollectMethod != nil {
			r.Collector.Conf.CollectMethod = types.StringValue(string(*resp.Collector.Conf.CollectMethod))
		} else {
			r.Collector.Conf.CollectMethod = types.StringNull()
		}
		r.Collector.Conf.CollectURL = types.StringPointerValue(resp.Collector.Conf.CollectURL)
		r.Collector.Conf.ConnectionID = types.StringPointerValue(resp.Collector.Conf.ConnectionID)
		r.Collector.Conf.ConnectionString = types.StringPointerValue(resp.Collector.Conf.ConnectionString)
		r.Collector.Conf.ContainerName = types.StringPointerValue(resp.Collector.Conf.ContainerName)
		r.Collector.Conf.CredentialsSecret = types.StringPointerValue(resp.Collector.Conf.CredentialsSecret)
		r.Collector.Conf.Dataset = types.StringPointerValue(resp.Collector.Conf.Dataset)
		r.Collector.Conf.DisableTimeFilter = types.BoolPointerValue(resp.Collector.Conf.DisableTimeFilter)
		r.Collector.Conf.Earliest = types.StringPointerValue(resp.Collector.Conf.Earliest)
		r.Collector.Conf.Endpoint = types.StringPointerValue(resp.Collector.Conf.Endpoint)
		r.Collector.Conf.HandleEscapedChars = types.BoolPointerValue(resp.Collector.Conf.HandleEscapedChars)
		r.Collector.Conf.Latest = types.StringPointerValue(resp.Collector.Conf.Latest)
		r.Collector.Conf.MaxBatchSize = types.Int64PointerValue(resp.Collector.Conf.MaxBatchSize)
		if resp.Collector.Conf.OutputMode != nil {
			r.Collector.Conf.OutputMode = types.StringValue(string(*resp.Collector.Conf.OutputMode))
		} else {
			r.Collector.Conf.OutputMode = types.StringNull()
		}
		r.Collector.Conf.Password = types.StringPointerValue(resp.Collector.Conf.Password)
		r.Collector.Conf.Path = types.StringPointerValue(resp.Collector.Conf.Path)
		r.Collector.Conf.Query = types.StringPointerValue(resp.Collector.Conf.Query)
		r.Collector.Conf.QueryValidationEnabled = types.BoolPointerValue(resp.Collector.Conf.QueryValidationEnabled)
		r.Collector.Conf.Recurse = types.BoolPointerValue(resp.Collector.Conf.Recurse)
		r.Collector.Conf.Region = types.StringPointerValue(resp.Collector.Conf.Region)
		r.Collector.Conf.RejectUnauthorized = types.BoolPointerValue(resp.Collector.Conf.RejectUnauthorized)
		r.Collector.Conf.Search = types.StringPointerValue(resp.Collector.Conf.Search)
		r.Collector.Conf.SearchHead = types.StringPointerValue(resp.Collector.Conf.SearchHead)
		r.Collector.Conf.ServiceAccountCredentials = types.StringPointerValue(resp.Collector.Conf.ServiceAccountCredentials)
		r.Collector.Conf.StorageAccountName = types.StringPointerValue(resp.Collector.Conf.StorageAccountName)
		r.Collector.Conf.Timeout = types.Int64PointerValue(resp.Collector.Conf.Timeout)
		r.Collector.Conf.Token = types.StringPointerValue(resp.Collector.Conf.Token)
		r.Collector.Conf.TokenSecret = types.StringPointerValue(resp.Collector.Conf.TokenSecret)
		r.Collector.Conf.Username = types.StringPointerValue(resp.Collector.Conf.Username)
		r.Collector.Conf.UseRoundRobinDNS = types.BoolPointerValue(resp.Collector.Conf.UseRoundRobinDNS)
	}
	r.Collector.Destructive = types.BoolPointerValue(resp.Collector.Destructive)
	r.Collector.Encoding = types.StringPointerValue(resp.Collector.Encoding)
	r.Collector.Type = types.StringValue(string(resp.Collector.Type))
	r.Environment = types.StringPointerValue(resp.Environment)
	r.ID = types.StringPointerValue(resp.ID)
	r.IgnoreGroupJobsLimit = types.BoolPointerValue(resp.IgnoreGroupJobsLimit)
	if resp.Input == nil {
		r.Input = nil
	} else {
		r.Input = &tfTypes.InputCollectorInput{}
		r.Input.BreakerRulesets = make([]types.String, 0, len(resp.Input.BreakerRulesets))
		for _, v := range resp.Input.BreakerRulesets {
			r.Input.BreakerRulesets = append(r.Input.BreakerRulesets, types.StringValue(v))
		}
		r.Input.Metadata = []tfTypes.InputCollectorMetadatum{}

		for _, metadataItem := range resp.Input.Metadata {
			var metadata tfTypes.InputCollectorMetadatum

			metadata.Name = types.StringValue(metadataItem.Name)
			metadata.Value = types.StringValue(metadataItem.Value)

			r.Input.Metadata = append(r.Input.Metadata, metadata)
		}
		r.Input.Output = types.StringPointerValue(resp.Input.Output)
		r.Input.Pipeline = types.StringPointerValue(resp.Input.Pipeline)
		if resp.Input.Preprocess == nil {
			r.Input.Preprocess = nil
		} else {
			r.Input.Preprocess = &tfTypes.InputCollectorPreprocess{}
			r.Input.Preprocess.Args = make([]types.String, 0, len(resp.Input.Preprocess.Args))
			for _, v := range resp.Input.Preprocess.Args {
				r.Input.Preprocess.Args = append(r.Input.Preprocess.Args, types.StringValue(v))
			}
			r.Input.Preprocess.Command = types.StringPointerValue(resp.Input.Preprocess.Command)
			r.Input.Preprocess.Disabled = types.BoolPointerValue(resp.Input.Preprocess.Disabled)
		}
		r.Input.SendToRoutes = types.BoolPointerValue(resp.Input.SendToRoutes)
		r.Input.StaleChannelFlushMs = types.Float64PointerValue(resp.Input.StaleChannelFlushMs)
		r.Input.ThrottleRatePerSec = types.StringPointerValue(resp.Input.ThrottleRatePerSec)
		if resp.Input.Type != nil {
			r.Input.Type = types.StringValue(string(*resp.Input.Type))
		} else {
			r.Input.Type = types.StringNull()
		}
	}
	r.RemoveFields = make([]types.String, 0, len(resp.RemoveFields))
	for _, v := range resp.RemoveFields {
		r.RemoveFields = append(r.RemoveFields, types.StringValue(v))
	}
	r.ResumeOnBoot = types.BoolPointerValue(resp.ResumeOnBoot)
	if resp.Schedule == nil {
		r.Schedule = nil
	} else {
		r.Schedule = &tfTypes.InputCollectorSchedule{}
		r.Schedule.CronSchedule = types.StringPointerValue(resp.Schedule.CronSchedule)
		r.Schedule.Enabled = types.BoolPointerValue(resp.Schedule.Enabled)
		r.Schedule.MaxConcurrentRuns = types.Float64PointerValue(resp.Schedule.MaxConcurrentRuns)
		if resp.Schedule.Run == nil {
			r.Schedule.Run = nil
		} else {
			r.Schedule.Run = &tfTypes.InputCollectorRunSettings{}
			r.Schedule.Run.Earliest = types.Float64PointerValue(resp.Schedule.Run.Earliest)
			r.Schedule.Run.Expression = types.StringPointerValue(resp.Schedule.Run.Expression)
			r.Schedule.Run.JobTimeout = types.StringPointerValue(resp.Schedule.Run.JobTimeout)
			r.Schedule.Run.Latest = types.Float64PointerValue(resp.Schedule.Run.Latest)
			if resp.Schedule.Run.LogLevel != nil {
				r.Schedule.Run.LogLevel = types.StringValue(string(*resp.Schedule.Run.LogLevel))
			} else {
				r.Schedule.Run.LogLevel = types.StringNull()
			}
			r.Schedule.Run.MaxTaskReschedule = types.Float64PointerValue(resp.Schedule.Run.MaxTaskReschedule)
			r.Schedule.Run.MaxTaskSize = types.StringPointerValue(resp.Schedule.Run.MaxTaskSize)
			r.Schedule.Run.MinTaskSize = types.StringPointerValue(resp.Schedule.Run.MinTaskSize)
			r.Schedule.Run.Mode = types.StringPointerValue(resp.Schedule.Run.Mode)
			r.Schedule.Run.RescheduleDroppedTasks = types.BoolPointerValue(resp.Schedule.Run.RescheduleDroppedTasks)
			r.Schedule.Run.TimeRangeType = types.StringPointerValue(resp.Schedule.Run.TimeRangeType)
		}
		r.Schedule.Skippable = types.BoolPointerValue(resp.Schedule.Skippable)
	}
	r.Streamtags = make([]types.String, 0, len(resp.Streamtags))
	for _, v := range resp.Streamtags {
		r.Streamtags = append(r.Streamtags, types.StringValue(v))
	}
	r.TTL = types.StringPointerValue(resp.TTL)
	r.WorkerAffinity = types.BoolPointerValue(resp.WorkerAffinity)

	return diags
}

func (r *CollectorResourceModel) ToOperationsCreateSavedJobRequest(ctx context.Context) (*operations.CreateSavedJobRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var groupID string
	groupID = r.GroupID.ValueString()

	inputCollector, inputCollectorDiags := r.ToSharedInputCollector(ctx)
	diags.Append(inputCollectorDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateSavedJobRequest{
		GroupID:        groupID,
		InputCollector: *inputCollector,
	}

	return &out, diags
}

func (r *CollectorResourceModel) ToOperationsDeleteCollectorByIDRequest(ctx context.Context) (*operations.DeleteCollectorByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	var groupID string
	groupID = r.GroupID.ValueString()

	out := operations.DeleteCollectorByIDRequest{
		ID:      id,
		GroupID: groupID,
	}

	return &out, diags
}

func (r *CollectorResourceModel) ToOperationsGetSavedJobByIDRequest(ctx context.Context) (*operations.GetSavedJobByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	var groupID string
	groupID = r.GroupID.ValueString()

	out := operations.GetSavedJobByIDRequest{
		ID:      id,
		GroupID: groupID,
	}

	return &out, diags
}

func (r *CollectorResourceModel) ToOperationsUpdateCollectorByIDRequest(ctx context.Context) (*operations.UpdateCollectorByIDRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	var groupID string
	groupID = r.GroupID.ValueString()

	inputCollector, inputCollectorDiags := r.ToSharedInputCollector(ctx)
	diags.Append(inputCollectorDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateCollectorByIDRequest{
		ID:             id,
		GroupID:        groupID,
		InputCollector: *inputCollector,
	}

	return &out, diags
}

func (r *CollectorResourceModel) ToSharedInputCollector(ctx context.Context) (*shared.InputCollector, diag.Diagnostics) {
	var diags diag.Diagnostics

	id := new(string)
	if !r.ID.IsUnknown() && !r.ID.IsNull() {
		*id = r.ID.ValueString()
	} else {
		id = nil
	}
	ttl := new(string)
	if !r.TTL.IsUnknown() && !r.TTL.IsNull() {
		*ttl = r.TTL.ValueString()
	} else {
		ttl = nil
	}
	ignoreGroupJobsLimit := new(bool)
	if !r.IgnoreGroupJobsLimit.IsUnknown() && !r.IgnoreGroupJobsLimit.IsNull() {
		*ignoreGroupJobsLimit = r.IgnoreGroupJobsLimit.ValueBool()
	} else {
		ignoreGroupJobsLimit = nil
	}
	removeFields := make([]string, 0, len(r.RemoveFields))
	for _, removeFieldsItem := range r.RemoveFields {
		removeFields = append(removeFields, removeFieldsItem.ValueString())
	}
	resumeOnBoot := new(bool)
	if !r.ResumeOnBoot.IsUnknown() && !r.ResumeOnBoot.IsNull() {
		*resumeOnBoot = r.ResumeOnBoot.ValueBool()
	} else {
		resumeOnBoot = nil
	}
	environment := new(string)
	if !r.Environment.IsUnknown() && !r.Environment.IsNull() {
		*environment = r.Environment.ValueString()
	} else {
		environment = nil
	}
	var schedule *shared.InputCollectorSchedule
	if r.Schedule != nil {
		enabled := new(bool)
		if !r.Schedule.Enabled.IsUnknown() && !r.Schedule.Enabled.IsNull() {
			*enabled = r.Schedule.Enabled.ValueBool()
		} else {
			enabled = nil
		}
		cronSchedule := new(string)
		if !r.Schedule.CronSchedule.IsUnknown() && !r.Schedule.CronSchedule.IsNull() {
			*cronSchedule = r.Schedule.CronSchedule.ValueString()
		} else {
			cronSchedule = nil
		}
		maxConcurrentRuns := new(float64)
		if !r.Schedule.MaxConcurrentRuns.IsUnknown() && !r.Schedule.MaxConcurrentRuns.IsNull() {
			*maxConcurrentRuns = r.Schedule.MaxConcurrentRuns.ValueFloat64()
		} else {
			maxConcurrentRuns = nil
		}
		skippable := new(bool)
		if !r.Schedule.Skippable.IsUnknown() && !r.Schedule.Skippable.IsNull() {
			*skippable = r.Schedule.Skippable.ValueBool()
		} else {
			skippable = nil
		}
		var run *shared.InputCollectorRunSettings
		if r.Schedule.Run != nil {
			rescheduleDroppedTasks := new(bool)
			if !r.Schedule.Run.RescheduleDroppedTasks.IsUnknown() && !r.Schedule.Run.RescheduleDroppedTasks.IsNull() {
				*rescheduleDroppedTasks = r.Schedule.Run.RescheduleDroppedTasks.ValueBool()
			} else {
				rescheduleDroppedTasks = nil
			}
			maxTaskReschedule := new(float64)
			if !r.Schedule.Run.MaxTaskReschedule.IsUnknown() && !r.Schedule.Run.MaxTaskReschedule.IsNull() {
				*maxTaskReschedule = r.Schedule.Run.MaxTaskReschedule.ValueFloat64()
			} else {
				maxTaskReschedule = nil
			}
			logLevel := new(shared.InputCollectorLogLevel)
			if !r.Schedule.Run.LogLevel.IsUnknown() && !r.Schedule.Run.LogLevel.IsNull() {
				*logLevel = shared.InputCollectorLogLevel(r.Schedule.Run.LogLevel.ValueString())
			} else {
				logLevel = nil
			}
			jobTimeout := new(string)
			if !r.Schedule.Run.JobTimeout.IsUnknown() && !r.Schedule.Run.JobTimeout.IsNull() {
				*jobTimeout = r.Schedule.Run.JobTimeout.ValueString()
			} else {
				jobTimeout = nil
			}
			mode := new(string)
			if !r.Schedule.Run.Mode.IsUnknown() && !r.Schedule.Run.Mode.IsNull() {
				*mode = r.Schedule.Run.Mode.ValueString()
			} else {
				mode = nil
			}
			timeRangeType := new(string)
			if !r.Schedule.Run.TimeRangeType.IsUnknown() && !r.Schedule.Run.TimeRangeType.IsNull() {
				*timeRangeType = r.Schedule.Run.TimeRangeType.ValueString()
			} else {
				timeRangeType = nil
			}
			earliest := new(float64)
			if !r.Schedule.Run.Earliest.IsUnknown() && !r.Schedule.Run.Earliest.IsNull() {
				*earliest = r.Schedule.Run.Earliest.ValueFloat64()
			} else {
				earliest = nil
			}
			latest := new(float64)
			if !r.Schedule.Run.Latest.IsUnknown() && !r.Schedule.Run.Latest.IsNull() {
				*latest = r.Schedule.Run.Latest.ValueFloat64()
			} else {
				latest = nil
			}
			expression := new(string)
			if !r.Schedule.Run.Expression.IsUnknown() && !r.Schedule.Run.Expression.IsNull() {
				*expression = r.Schedule.Run.Expression.ValueString()
			} else {
				expression = nil
			}
			minTaskSize := new(string)
			if !r.Schedule.Run.MinTaskSize.IsUnknown() && !r.Schedule.Run.MinTaskSize.IsNull() {
				*minTaskSize = r.Schedule.Run.MinTaskSize.ValueString()
			} else {
				minTaskSize = nil
			}
			maxTaskSize := new(string)
			if !r.Schedule.Run.MaxTaskSize.IsUnknown() && !r.Schedule.Run.MaxTaskSize.IsNull() {
				*maxTaskSize = r.Schedule.Run.MaxTaskSize.ValueString()
			} else {
				maxTaskSize = nil
			}
			run = &shared.InputCollectorRunSettings{
				RescheduleDroppedTasks: rescheduleDroppedTasks,
				MaxTaskReschedule:      maxTaskReschedule,
				LogLevel:               logLevel,
				JobTimeout:             jobTimeout,
				Mode:                   mode,
				TimeRangeType:          timeRangeType,
				Earliest:               earliest,
				Latest:                 latest,
				Expression:             expression,
				MinTaskSize:            minTaskSize,
				MaxTaskSize:            maxTaskSize,
			}
		}
		schedule = &shared.InputCollectorSchedule{
			Enabled:           enabled,
			CronSchedule:      cronSchedule,
			MaxConcurrentRuns: maxConcurrentRuns,
			Skippable:         skippable,
			Run:               run,
		}
	}
	streamtags := make([]string, 0, len(r.Streamtags))
	for _, streamtagsItem := range r.Streamtags {
		streamtags = append(streamtags, streamtagsItem.ValueString())
	}
	workerAffinity := new(bool)
	if !r.WorkerAffinity.IsUnknown() && !r.WorkerAffinity.IsNull() {
		*workerAffinity = r.WorkerAffinity.ValueBool()
	} else {
		workerAffinity = nil
	}
	var input *shared.InputCollectorInput
	if r.Input != nil {
		typeVar := new(shared.InputCollectorType2)
		if !r.Input.Type.IsUnknown() && !r.Input.Type.IsNull() {
			*typeVar = shared.InputCollectorType2(r.Input.Type.ValueString())
		} else {
			typeVar = nil
		}
		breakerRulesets := make([]string, 0, len(r.Input.BreakerRulesets))
		for _, breakerRulesetsItem := range r.Input.BreakerRulesets {
			breakerRulesets = append(breakerRulesets, breakerRulesetsItem.ValueString())
		}
		staleChannelFlushMs := new(float64)
		if !r.Input.StaleChannelFlushMs.IsUnknown() && !r.Input.StaleChannelFlushMs.IsNull() {
			*staleChannelFlushMs = r.Input.StaleChannelFlushMs.ValueFloat64()
		} else {
			staleChannelFlushMs = nil
		}
		sendToRoutes := new(bool)
		if !r.Input.SendToRoutes.IsUnknown() && !r.Input.SendToRoutes.IsNull() {
			*sendToRoutes = r.Input.SendToRoutes.ValueBool()
		} else {
			sendToRoutes = nil
		}
		var preprocess *shared.InputCollectorPreprocess
		if r.Input.Preprocess != nil {
			disabled := new(bool)
			if !r.Input.Preprocess.Disabled.IsUnknown() && !r.Input.Preprocess.Disabled.IsNull() {
				*disabled = r.Input.Preprocess.Disabled.ValueBool()
			} else {
				disabled = nil
			}
			command := new(string)
			if !r.Input.Preprocess.Command.IsUnknown() && !r.Input.Preprocess.Command.IsNull() {
				*command = r.Input.Preprocess.Command.ValueString()
			} else {
				command = nil
			}
			args := make([]string, 0, len(r.Input.Preprocess.Args))
			for _, argsItem := range r.Input.Preprocess.Args {
				args = append(args, argsItem.ValueString())
			}
			preprocess = &shared.InputCollectorPreprocess{
				Disabled: disabled,
				Command:  command,
				Args:     args,
			}
		}
		throttleRatePerSec := new(string)
		if !r.Input.ThrottleRatePerSec.IsUnknown() && !r.Input.ThrottleRatePerSec.IsNull() {
			*throttleRatePerSec = r.Input.ThrottleRatePerSec.ValueString()
		} else {
			throttleRatePerSec = nil
		}
		metadata := make([]shared.InputCollectorMetadatum, 0, len(r.Input.Metadata))
		for _, metadataItem := range r.Input.Metadata {
			var name string
			name = metadataItem.Name.ValueString()

			var value string
			value = metadataItem.Value.ValueString()

			metadata = append(metadata, shared.InputCollectorMetadatum{
				Name:  name,
				Value: value,
			})
		}
		pipeline := new(string)
		if !r.Input.Pipeline.IsUnknown() && !r.Input.Pipeline.IsNull() {
			*pipeline = r.Input.Pipeline.ValueString()
		} else {
			pipeline = nil
		}
		output := new(string)
		if !r.Input.Output.IsUnknown() && !r.Input.Output.IsNull() {
			*output = r.Input.Output.ValueString()
		} else {
			output = nil
		}
		input = &shared.InputCollectorInput{
			Type:                typeVar,
			BreakerRulesets:     breakerRulesets,
			StaleChannelFlushMs: staleChannelFlushMs,
			SendToRoutes:        sendToRoutes,
			Preprocess:          preprocess,
			ThrottleRatePerSec:  throttleRatePerSec,
			Metadata:            metadata,
			Pipeline:            pipeline,
			Output:              output,
		}
	}
	typeVar1 := shared.CollectorType(r.Collector.Type.ValueString())
	destructive := new(bool)
	if !r.Collector.Destructive.IsUnknown() && !r.Collector.Destructive.IsNull() {
		*destructive = r.Collector.Destructive.ValueBool()
	} else {
		destructive = nil
	}
	encoding := new(string)
	if !r.Collector.Encoding.IsUnknown() && !r.Collector.Encoding.IsNull() {
		*encoding = r.Collector.Encoding.ValueString()
	} else {
		encoding = nil
	}
	var conf *shared.InputCollectorConf
	if r.Collector.Conf != nil {
		searchHead := new(string)
		if !r.Collector.Conf.SearchHead.IsUnknown() && !r.Collector.Conf.SearchHead.IsNull() {
			*searchHead = r.Collector.Conf.SearchHead.ValueString()
		} else {
			searchHead = nil
		}
		search := new(string)
		if !r.Collector.Conf.Search.IsUnknown() && !r.Collector.Conf.Search.IsNull() {
			*search = r.Collector.Conf.Search.ValueString()
		} else {
			search = nil
		}
		earliest1 := new(string)
		if !r.Collector.Conf.Earliest.IsUnknown() && !r.Collector.Conf.Earliest.IsNull() {
			*earliest1 = r.Collector.Conf.Earliest.ValueString()
		} else {
			earliest1 = nil
		}
		latest1 := new(string)
		if !r.Collector.Conf.Latest.IsUnknown() && !r.Collector.Conf.Latest.IsNull() {
			*latest1 = r.Collector.Conf.Latest.ValueString()
		} else {
			latest1 = nil
		}
		endpoint := new(string)
		if !r.Collector.Conf.Endpoint.IsUnknown() && !r.Collector.Conf.Endpoint.IsNull() {
			*endpoint = r.Collector.Conf.Endpoint.ValueString()
		} else {
			endpoint = nil
		}
		outputMode := new(shared.InputCollectorOutputMode)
		if !r.Collector.Conf.OutputMode.IsUnknown() && !r.Collector.Conf.OutputMode.IsNull() {
			*outputMode = shared.InputCollectorOutputMode(r.Collector.Conf.OutputMode.ValueString())
		} else {
			outputMode = nil
		}
		authentication := new(shared.AuthenticationEnum)
		if !r.Collector.Conf.Authentication.IsUnknown() && !r.Collector.Conf.Authentication.IsNull() {
			*authentication = shared.AuthenticationEnum(r.Collector.Conf.Authentication.ValueString())
		} else {
			authentication = nil
		}
		timeout := new(int64)
		if !r.Collector.Conf.Timeout.IsUnknown() && !r.Collector.Conf.Timeout.IsNull() {
			*timeout = r.Collector.Conf.Timeout.ValueInt64()
		} else {
			timeout = nil
		}
		useRoundRobinDNS := new(bool)
		if !r.Collector.Conf.UseRoundRobinDNS.IsUnknown() && !r.Collector.Conf.UseRoundRobinDNS.IsNull() {
			*useRoundRobinDNS = r.Collector.Conf.UseRoundRobinDNS.ValueBool()
		} else {
			useRoundRobinDNS = nil
		}
		disableTimeFilter := new(bool)
		if !r.Collector.Conf.DisableTimeFilter.IsUnknown() && !r.Collector.Conf.DisableTimeFilter.IsNull() {
			*disableTimeFilter = r.Collector.Conf.DisableTimeFilter.ValueBool()
		} else {
			disableTimeFilter = nil
		}
		rejectUnauthorized := new(bool)
		if !r.Collector.Conf.RejectUnauthorized.IsUnknown() && !r.Collector.Conf.RejectUnauthorized.IsNull() {
			*rejectUnauthorized = r.Collector.Conf.RejectUnauthorized.ValueBool()
		} else {
			rejectUnauthorized = nil
		}
		handleEscapedChars := new(bool)
		if !r.Collector.Conf.HandleEscapedChars.IsUnknown() && !r.Collector.Conf.HandleEscapedChars.IsNull() {
			*handleEscapedChars = r.Collector.Conf.HandleEscapedChars.ValueBool()
		} else {
			handleEscapedChars = nil
		}
		username := new(string)
		if !r.Collector.Conf.Username.IsUnknown() && !r.Collector.Conf.Username.IsNull() {
			*username = r.Collector.Conf.Username.ValueString()
		} else {
			username = nil
		}
		password := new(string)
		if !r.Collector.Conf.Password.IsUnknown() && !r.Collector.Conf.Password.IsNull() {
			*password = r.Collector.Conf.Password.ValueString()
		} else {
			password = nil
		}
		credentialsSecret := new(string)
		if !r.Collector.Conf.CredentialsSecret.IsUnknown() && !r.Collector.Conf.CredentialsSecret.IsNull() {
			*credentialsSecret = r.Collector.Conf.CredentialsSecret.ValueString()
		} else {
			credentialsSecret = nil
		}
		token := new(string)
		if !r.Collector.Conf.Token.IsUnknown() && !r.Collector.Conf.Token.IsNull() {
			*token = r.Collector.Conf.Token.ValueString()
		} else {
			token = nil
		}
		tokenSecret := new(string)
		if !r.Collector.Conf.TokenSecret.IsUnknown() && !r.Collector.Conf.TokenSecret.IsNull() {
			*tokenSecret = r.Collector.Conf.TokenSecret.ValueString()
		} else {
			tokenSecret = nil
		}
		bucket := new(string)
		if !r.Collector.Conf.Bucket.IsUnknown() && !r.Collector.Conf.Bucket.IsNull() {
			*bucket = r.Collector.Conf.Bucket.ValueString()
		} else {
			bucket = nil
		}
		region := new(string)
		if !r.Collector.Conf.Region.IsUnknown() && !r.Collector.Conf.Region.IsNull() {
			*region = r.Collector.Conf.Region.ValueString()
		} else {
			region = nil
		}
		path := new(string)
		if !r.Collector.Conf.Path.IsUnknown() && !r.Collector.Conf.Path.IsNull() {
			*path = r.Collector.Conf.Path.ValueString()
		} else {
			path = nil
		}
		awsAuthenticationMethod := new(shared.InputCollectorAwsAuthenticationMethodAuthenticationMethod)
		if !r.Collector.Conf.AwsAuthenticationMethod.IsUnknown() && !r.Collector.Conf.AwsAuthenticationMethod.IsNull() {
			*awsAuthenticationMethod = shared.InputCollectorAwsAuthenticationMethodAuthenticationMethod(r.Collector.Conf.AwsAuthenticationMethod.ValueString())
		} else {
			awsAuthenticationMethod = nil
		}
		awsAPIKey := new(string)
		if !r.Collector.Conf.AwsAPIKey.IsUnknown() && !r.Collector.Conf.AwsAPIKey.IsNull() {
			*awsAPIKey = r.Collector.Conf.AwsAPIKey.ValueString()
		} else {
			awsAPIKey = nil
		}
		awsSecretKey := new(string)
		if !r.Collector.Conf.AwsSecretKey.IsUnknown() && !r.Collector.Conf.AwsSecretKey.IsNull() {
			*awsSecretKey = r.Collector.Conf.AwsSecretKey.ValueString()
		} else {
			awsSecretKey = nil
		}
		awsSecret := new(string)
		if !r.Collector.Conf.AwsSecret.IsUnknown() && !r.Collector.Conf.AwsSecret.IsNull() {
			*awsSecret = r.Collector.Conf.AwsSecret.ValueString()
		} else {
			awsSecret = nil
		}
		recurse := new(bool)
		if !r.Collector.Conf.Recurse.IsUnknown() && !r.Collector.Conf.Recurse.IsNull() {
			*recurse = r.Collector.Conf.Recurse.ValueBool()
		} else {
			recurse = nil
		}
		extractors := make([]shared.Extractor, len(r.Collector.Conf.Extractors))
		maxBatchSize := new(int64)
		if !r.Collector.Conf.MaxBatchSize.IsUnknown() && !r.Collector.Conf.MaxBatchSize.IsNull() {
			*maxBatchSize = r.Collector.Conf.MaxBatchSize.ValueInt64()
		} else {
			maxBatchSize = nil
		}
		containerName := new(string)
		if !r.Collector.Conf.ContainerName.IsUnknown() && !r.Collector.Conf.ContainerName.IsNull() {
			*containerName = r.Collector.Conf.ContainerName.ValueString()
		} else {
			containerName = nil
		}
		storageAccountName := new(string)
		if !r.Collector.Conf.StorageAccountName.IsUnknown() && !r.Collector.Conf.StorageAccountName.IsNull() {
			*storageAccountName = r.Collector.Conf.StorageAccountName.ValueString()
		} else {
			storageAccountName = nil
		}
		connectionString := new(string)
		if !r.Collector.Conf.ConnectionString.IsUnknown() && !r.Collector.Conf.ConnectionString.IsNull() {
			*connectionString = r.Collector.Conf.ConnectionString.ValueString()
		} else {
			connectionString = nil
		}
		authType := new(shared.InputCollectorAuthTypeAuthenticationMethod)
		if !r.Collector.Conf.AuthType.IsUnknown() && !r.Collector.Conf.AuthType.IsNull() {
			*authType = shared.InputCollectorAuthTypeAuthenticationMethod(r.Collector.Conf.AuthType.ValueString())
		} else {
			authType = nil
		}
		dataset := new(string)
		if !r.Collector.Conf.Dataset.IsUnknown() && !r.Collector.Conf.Dataset.IsNull() {
			*dataset = r.Collector.Conf.Dataset.ValueString()
		} else {
			dataset = nil
		}
		connectionID := new(string)
		if !r.Collector.Conf.ConnectionID.IsUnknown() && !r.Collector.Conf.ConnectionID.IsNull() {
			*connectionID = r.Collector.Conf.ConnectionID.ValueString()
		} else {
			connectionID = nil
		}
		query := new(string)
		if !r.Collector.Conf.Query.IsUnknown() && !r.Collector.Conf.Query.IsNull() {
			*query = r.Collector.Conf.Query.ValueString()
		} else {
			query = nil
		}
		queryValidationEnabled := new(bool)
		if !r.Collector.Conf.QueryValidationEnabled.IsUnknown() && !r.Collector.Conf.QueryValidationEnabled.IsNull() {
			*queryValidationEnabled = r.Collector.Conf.QueryValidationEnabled.ValueBool()
		} else {
			queryValidationEnabled = nil
		}
		serviceAccountCredentials := new(string)
		if !r.Collector.Conf.ServiceAccountCredentials.IsUnknown() && !r.Collector.Conf.ServiceAccountCredentials.IsNull() {
			*serviceAccountCredentials = r.Collector.Conf.ServiceAccountCredentials.ValueString()
		} else {
			serviceAccountCredentials = nil
		}
		collectURL := new(string)
		if !r.Collector.Conf.CollectURL.IsUnknown() && !r.Collector.Conf.CollectURL.IsNull() {
			*collectURL = r.Collector.Conf.CollectURL.ValueString()
		} else {
			collectURL = nil
		}
		collectMethod := new(shared.CollectMethod)
		if !r.Collector.Conf.CollectMethod.IsUnknown() && !r.Collector.Conf.CollectMethod.IsNull() {
			*collectMethod = shared.CollectMethod(r.Collector.Conf.CollectMethod.ValueString())
		} else {
			collectMethod = nil
		}
		conf = &shared.InputCollectorConf{
			SearchHead:                searchHead,
			Search:                    search,
			Earliest:                  earliest1,
			Latest:                    latest1,
			Endpoint:                  endpoint,
			OutputMode:                outputMode,
			Authentication:            authentication,
			Timeout:                   timeout,
			UseRoundRobinDNS:          useRoundRobinDNS,
			DisableTimeFilter:         disableTimeFilter,
			RejectUnauthorized:        rejectUnauthorized,
			HandleEscapedChars:        handleEscapedChars,
			Username:                  username,
			Password:                  password,
			CredentialsSecret:         credentialsSecret,
			Token:                     token,
			TokenSecret:               tokenSecret,
			Bucket:                    bucket,
			Region:                    region,
			Path:                      path,
			AwsAuthenticationMethod:   awsAuthenticationMethod,
			AwsAPIKey:                 awsAPIKey,
			AwsSecretKey:              awsSecretKey,
			AwsSecret:                 awsSecret,
			Recurse:                   recurse,
			Extractors:                extractors,
			MaxBatchSize:              maxBatchSize,
			ContainerName:             containerName,
			StorageAccountName:        storageAccountName,
			ConnectionString:          connectionString,
			AuthType:                  authType,
			Dataset:                   dataset,
			ConnectionID:              connectionID,
			Query:                     query,
			QueryValidationEnabled:    queryValidationEnabled,
			ServiceAccountCredentials: serviceAccountCredentials,
			CollectURL:                collectURL,
			CollectMethod:             collectMethod,
		}
	}
	collector := shared.InputCollectorCollector{
		Type:        typeVar1,
		Destructive: destructive,
		Encoding:    encoding,
		Conf:        conf,
	}
	out := shared.InputCollector{
		ID:                   id,
		TTL:                  ttl,
		IgnoreGroupJobsLimit: ignoreGroupJobsLimit,
		RemoveFields:         removeFields,
		ResumeOnBoot:         resumeOnBoot,
		Environment:          environment,
		Schedule:             schedule,
		Streamtags:           streamtags,
		WorkerAffinity:       workerAffinity,
		Input:                input,
		Collector:            collector,
	}

	return &out, diags
}
